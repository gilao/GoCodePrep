# 00-Go与其他语言

## 0.什么是面向对象：

### 面向对象 OOP：

* 面向对象编程是一种基于对象概念的编程范式，它可以包含数据和代码：数据以字段的形式存在（通常称为属性），代码是程序的形式存在（通常称为方法）；
* 对象自己的程序可以访问并经常修改自己的数据字段。
* 对象经常被定义为类的一个实例。
* 对象利用属性和方法的私有/受保护/公共可见性，对象的内部状态受到保护，不受外界影响（被封装）。

面向对象的三个基本特性；

* 封装
* 继承
* 多态

## 1.Go语言和Java有什么区别

1、Go上不允许函数重载，必须具有方法和函数的唯一名称，而Java允许函数重载。

2、在速度方面，Go的速度要比Java快。

3、Java默认允许多态，而Go没有。

4、Go语言使用HTTP协议进行路由配置，而Java使用Akka.routing.ConsistentHashingRouter和Akka.routing.ScatterGatherFirstCompletedRouter进行路由配置。

5、Go代码可以自动扩展到多个核心，而Java并不总是具有足够的可扩展性。

6、Go语言的继承通过匿名组合完成，基类以Struct的方式定义，子类只需要把基类作为成员放在子类的定义中，支持多继承;而Java的继承通过extends关键字完成，不支持多继承。

## 2.Go是面向对象的语言吗

是的，也不是。原因是：

1. Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次。
2. Go 中的 "接口 "概念提供了一种不同的方法，我们认为这种方法易于使用，而且在某些方面更加通用。还有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类。
3. Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、"未装箱的 "整数。它们并不局限于结构（类）。
4. Go 由于缺乏类型层次，Go 中的 "对象 "比 C++ 或 Java 等语言更轻巧。

## 3.Go实现面向对象编程

### 封装

向对象中的 “封装” 指的是可以隐藏对象的内部属性和实现细节，仅对外提供公开接口调用，这样子用户就不需要关注你内部是怎么实现的。

**在 Go 语言中的属性访问权限，通过首字母大小写来控制：**

- 首字母大写，代表是公共的、可被外部访问的。
- 首字母小写，代表是私有的，不可以被外部访问。

Go 语言的例子如下：

```
type Animal struct {
	name string
}

func NewAnimal() *Animal {
 	return &Animal{}
}

func (p *Animal) SetName(name string) {
 	p.name = name
}

func (p *Animal) GetName() string {
 	return p.name
}
```

在上述例子中，我们声明了一个结构体 Animal，其属性 name 为小写。没法通过外部方法，在配套上存在 Setter 和 Getter 的方法，用于统一的访问和设置控制。

### 继承

![image](E:/Typora%20picture/image-17209316396541.png)

从实际的例子来看，就是动物是一个大父类，下面又能细分为 “食草动物”、“食肉动物”，这两者会包含 “动物” 这个父类的基本定义。

**在 Go 语言中，是没有类似** **extends** **关键字的这种继承的方式，在语言设计上采取的是组合的方式**：

```go
type Animal struct {
 	Name string
}

type Cat struct {
 	Animal
 	FeatureA string
}

type Dog struct {
 	Animal
 	FeatureB string
}
```

在上述例子中，我们声明了 Cat 和 Dog 结构体，其在内部匿名组合了 Animal 结构体。因此 Cat 和 Dog 的实例都可以调用 Animal 结构体的方法：

```go
func main() {
 	p := NewAnimal()
 	p.SetName("我是搬运工，去给煎鱼点赞~")

 	dog := Dog{Animal: *p}
 	fmt.Println(dog.GetName())
}
```

上述例子能够正常包含调用 Animal 的相关属性和方法，也能够拥有自己的独立属性和方法，在 Go 语言中达到了类似继承的效果。

### 多态

面向对象中的 “多态” 指的同一个行为具有多种不同表现形式或形态的能力，具体是指一个类实例（对象）的相同方法在不同情形有不同表现形式。

多态也使得不同内部结构的对象可以共享相同的外部接口，也就是都是一套外部模板，内部实际是什么，只要符合规格就可以。

**在Go语言中，多态是通过接口来实现的**

```gO
type AnimalSounder interface {
 	MakeDNA()
}

func MakeSomeDNA(animalSounder AnimalSounder) {		// 参数是AnimalSounder接口类型
 	animalSounder.MakeDNA()
}
```

在上述例子中，我们声明了一个接口类型 AnimalSounder，配套一个 MakeSomeDNA 方法，其接受 AnimalSounder 接口类型作为入参。

因此在 Go 语言中。只要配套的 Cat 和 Dog 的实例也实现了 MakeSomeDNA 方法，那么我们就可以认为他是 AnimalSounder 接口类型：

```go
type AnimalSounder interface {
 	MakeDNA()
}

func MakeSomeDNA(animalSounder AnimalSounder) {
 	animalSounder.MakeDNA()
}

func (c *Cat) MakeDNA() {
 	fmt.Println("煎鱼是煎鱼")
}

func (c *Dog) MakeDNA() {
 	fmt.Println("煎鱼其实不是煎鱼")
}

func main() {
 	MakeSomeDNA(&Cat{})
 	MakeSomeDNA(&Dog{})
}
```

当 Cat 和 Dog 的实例实现了 AnimalSounder 接口类型的约束后，就意味着满足了条件，他们在 Go 语言中就是一个东西。能够作为入参传入 MakeSomeDNA 方法中，再根据不同的实例实现多态行为。

------

在日常工作中，基本了解这些概念就可以了。若是面试，可以针对三大特性：“封装、继承、多态” 和 五大原则 “单一职责原则（SRP）、开放封闭原则（OCP）、里氏替换原则（LSP）、依赖倒置原则（DIP）、接口隔离原则（ISP）” 进行深入理解和说明。

## 4.Go 语言和python的区别

1、范例

Python是一种基于面向对象编程的多范式，命令式和函数式编程语言。它坚持这样一种观点，即如果一种语言在某些情境中表现出某种特定的方式，理想情况下它应该在所有情境中都有相似的作用。但是，它又不是纯粹的OOP语言，它不支持强封装，这是OOP的主要原则之一。

Go是一种基于并发编程范式的过程编程语言，它与C具有表面相似性。实际上，Go更像是C的更新版本。

2、类型化

Python是动态类型语言，而Go是一种静态类型语言，它实际上有助于在编译时捕获错误，这可以进一步减少生产后期的严重错误。

3、并发

Python没有提供内置的并发机制，而Go有内置的并发机制。

4、安全性

Python是一种强类型语言，它是经过编译的，因此增加了一层安全性。Go具有分配给每个变量的类型，因此，它提供了安全性。但是，如果发生任何错误，用户需要自己运行整个代码。

5、管理内存

Go允许程序员在很大程度上管理内存。而，Python中的内存管理完全自动化并由Python VM管理；它不允许程序员对内存管理负责。

6、库

与Go相比，Python提供的库数量要大得多。然而，Go仍然是新的，并且还没有取得很大进展。

7、语法

Python的语法使用缩进来指示代码块。Go的语法基于打开和关闭括号。

8、详细程度

为了获得相同的功能，Golang代码通常需要编写比Python代码更多的字符。

# 01-基础部分

## 0.为什么选择golang

**0、高性能-协程**
golang 源码级别支持协程，实现简单；对比进程和线程，协程占用资源少，能够简洁高效地处理高并发问题。

**1、学习曲线容易-代码极简**

Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。

Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。

**2、效率：快速的编译时间，开发效率和运行效率高**

开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。

C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。

**3、出身名门、血统纯正**

之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。

**4、自由高效：组合的思想、无侵入式的接口**

Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。

**5、强大的标准库-生态**

背靠谷歌，生态丰富，轻松 go get 获取各种高质量轮子。用户可以专注于业务逻辑，避免重复造轮子。

这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。Go 语言的 lib 库麻雀虽小五脏俱全。Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。

**6、部署方便：二进制文件，Copy部署**

部署简单，源码编译成执行文件后，可以直接运行，减少了对其它插件依赖。不像其它语言，执行文件依赖各种插件，各种库，研发机器运行正常，部署到生产环境，死活跑不起来 。

**7、简单的并发**

并行和异步编程几乎无痛点。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。

Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。

创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。

**8、稳定性**

Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。

**9、跨平台**
很多语言都支持跨平台，把这个优点单独拿出来，貌似没有什么值得称道的，但是结合上述优点，它的综合能力就非常强了。

## 1.make 和new 的区别

* new 用于创建任何类型的零值指针

* make 用于初始化 slice、map和channel类型；

**共同点：给变量分配内存**

**不同点：**

1. 作用变量类型不同：new 可以给任意类型分配内存；make 给 slice、map、channel分配内存；
2. 返回类型不同：new 返回指向新分配的零值内存的指针，make初始化并返回一个可以直接使用的 slice、map 和 channel类型的值，而不是指针；
3. **new 分配的空间被初始化为其对应类型的零值，make分配空间后，会对 slice、map 和 channel 进行初始化，使其处于立即使用的状态，包括创建适当的底层数据结构和设置初始配置；**

## 2.IO多路复用

操作系统中IO多路复用中多路就是多个TCP连接，复用就是指复用一个或少量线程，理解起来就是多个网络连接的IO事件复用一个或少量线程来处理这些连接。一句话概括就是，**IO多路复用就是复用一个线程处理多个IO请求**。

## 3.for range 问题

1. 迭代顺序：数组、切片可以按照索引递增顺序迭代；map 不保证迭代顺序；
2. **复制元素vs 引用：**当你在 `for range` 循环中遍历切片或数组时，每次循环都会创建元素的一个副本。这意味着如果在循环内修改循环变量，不会影响原始切片或数组中的元素；对于映射和通道，`for range` 会返回键和值的副本。因此，如果在循环中修改这些值，不会影响映射中的原始值。
3. **并发问题**：如果在 `for range` 循环中启动新的 goroutine，循环变量在 goroutine 中可能是不可预测的。当循环结束时，循环变量的值可能会被重置，导致 goroutine 使用无效的值。为了避免这个问题，应该在每个 goroutine 中捕获循环变量的值。**当从一个通道读取时，`for range` 会阻塞直到通道关闭或者有可用的值。如果通道永远不会关闭且没有值发送，循环将永久阻塞。**
4. **映射迭代的终止条件**：映射的迭代器在映射被删除（`delete` 调用）时会停止，即使还有未迭代的元素。因此，在迭代映射时不要删除映射的元素。
5. **通道的关闭与检测：**当从通道读取时，如果通道被关闭且没有更多的值可以读取，`for range` 循环会终止。可以通过检查从通道读取的第二个返回值（布尔值）来确定是否是因为通道关闭而退出循环。

在 for a,b := range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不要直接把 a 或者 b 的地址传给协程。解决办法：在每次循环时，创建一个临时变量。

for range 问题在1.22版本后正式优化了该问题

## 4.defer，多个defer的执行顺序；defer在什么情况下会修改return 返回值

作用：延迟函数；释放资源；收尾工作；释放锁、关闭文件、关闭连接、捕获panic；

多个defer调用顺序：LIFO 后入先出

defer 会修改 有名返回值或函数返回指针；

## 5.uint类型溢出问题

超过最大存储值如uint8最大是255

var a uint8 =255

var b uint8 =1

a+b = 0总之类型溢出会出现难以意料的事

![image-20240714134112799](E:/Typora%20picture/image-20240714134112799.png)

## 6.rune类型

相当int32

golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8

==**byte 等同于int8，常用来处理ascii字符**==

==**rune 等同于int32,常用来处理unicode或utf-8字符**==

![image-20240714134201454](E:/Typora%20picture/image-20240714134201454.png)

## 7.解析tag是如何实现的

`tag`信息可以通过`反射（reflect包）`内的方法获取。

## 8.调用函数传入结构体时，应该传值还是指针

Golang 都是传值

Go 的函数参数传递都是值传递。

值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数

因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。

## 9.goroutine 什么情况下会阻塞

1. **通道操作**：
   - 当一个goroutine尝试从一个非缓冲通道读取数据而通道没有数据时，该goroutine会被阻塞，直到另一个goroutine向该通道发送数据。
   - 同样，当一个goroutine尝试向一个非缓冲通道发送数据而通道没有接收者时，该goroutine也会被阻塞，直到有另一个goroutine从该通道接收数据。
2. **同步原语**：
   - 使用如`sync.Mutex.Lock()`或`sync.RWMutex.Lock()`等互斥锁进行锁定时，如果锁已经被其他goroutine持有，那么当前goroutine将被阻塞，直到锁被释放。
   - `sync.WaitGroup.Wait()`方法会阻塞调用它的goroutine，直到所有调用了`WaitGroup.Done()`的goroutine完成。
3. **系统调用**：
   - 如果一个goroutine正在进行一个可能阻塞的系统调用（如网络I/O、文件I/O），那么在该调用完成之前，goroutine将被阻塞。
4. **函数/方法调用**：
   - 调用一个阻塞的函数或方法也会使goroutine阻塞，直到该函数或方法返回。
5. **死锁**：
   - 如果两个或多个goroutine互相等待对方持有的资源，就会发生死锁，所有涉及的goroutine都会被无限期地阻塞。
6. **select语句**：
   - 在没有可用操作的情况下，select语句也会阻塞，直到其中一个操作变为可执行状态。

## 10.讲讲Select底层数据结构和一些特性（项目中是如何使用 select的）

go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测是否有读写事件是否 ready。

**select 的特性**

1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。

2）select 仅支持管道，而且是单协程操作。

3）每个 case 语句仅能处理一个管道，要么读要么写。

4）多个 case 语句的执行顺序是随机的。

5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。

## 11.讲讲 defer 底层数据结构和一些特性

每个 defer 语句都对应一个_defer 实例， 多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果

* defer 列表
* defer 记录
* defer 链表

**defer 的规则总结**：

延迟函数的参数是 defer 语句出现的时候就已经确定了的。

延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。

延迟函数可能操作主函数的返回值。

申请资源后立即使用 defer 关闭资源是个好习惯。

## 12.单引号、双引号、反引号的区别

## 13.出现panic的场景

- 数组/切片越界
- 空指针调用。比如访问一个 nil 结构体指针的成员
- 过早关闭 HTTP 响应体
- 除以 0
- 向已经关闭的 channel 发送消息
- 重复关闭 channel
- 关闭未初始化的 channel
- 未初始化 map。注意访问 map 不存在的 key 不会 panic，而是返回 map 类型对应的零值，但是不能直接赋值
- 跨协程的 panic 处理
- sync 计数为负数。
- 类型断言不匹配。`var a interface{} = 1; fmt.Println(a.(string))` 会 panic，建议用 `s,ok := a.(string)`

## 14.go是否支持while循环，如何实现这种机制

```go
for {
    if i > 10 {	//循环条件
        break
    }	
}
```



## 15.go如何实现set

Go中不提供Set类型，Set是一个集合，其本质是一个List，只是List里的元素不能重复；

Go 提供了map类型，map类型的key是不能重复的，因此，我们可以利用这一点，来实现一个set。那value呢？value我们可以用一个常量来代替，比如一个空结构体，实际上空结构体不占任何内存，使用空结构体，能够帮我们节省内存空间，提高性能

## 16.go如何实现java的继承机制

本质上，Go使用interface实现的功能叫组合，Go是使用组合来实现的继承，说的更精确一点，是使用组合来代替的继承，举个很简单的例子:

```
type Animal struct {
    Name string
}

func (a *Animal) Eat() {
    fmt.Printf("%v is eating", a.Name)
    fmt.Println()
}

type Cat struct {
    *Animal
}

cat := &Cat{
    Animal: &Animal{
        Name: "cat",
    },
}
cat.Eat() // cat is eating
```

## 17.怎么去复用一个接口的方法

1. 实现相同的接口；

   ```go
   type MyInterface interface {
       MethodA()
       MethodB()
   }
   
   type TypeA struct{}
   func (t TypeA) MethodA() {}
   func (t TypeA) MethodB() {}
   
   type TypeB struct{}
   func (t TypeB) MethodA() {}
   func (t TypeB) MethodB() {}
   ```

2. 嵌入类型

   ```
   type Base struct {
       // ...
   }
   func (b Base) MethodA() {}
   func (b Base) MethodB() {}
   
   type Derived struct {
       Base
       // ...
   }
   ```

3. 使用组合：类似于嵌入类型，你也可以创建一个新的类型，它包含一个或多个实现了所需方法的类型。通过组合这些类型，新类型可以访问这些方法。

   ```
   type MethodSet struct {
       // 包含实现所需方法的字段
   }
   func (ms MethodSet) MethodA() {}
   func (ms MethodSet) MethodB() {}
   
   type NewType struct {
       ms MethodSet
   }
   ```

4. 适配器模式 如果你需要让一个现有类型适应一个接口，但这个类型本身不完全符合接口的要求，你可以创建一个适配器类型。适配器实现了接口，并将调用转发给原始类型。

   ```
   type Adapter struct {
       OriginalType
   }
   func (a Adapter) MethodA() {
       a.OriginalType.MethodX()
   }
   ```

## 18.go里面的_

1. 忽略返回值

2. 用在变量 特别是接口断言

3. 用在import package

   引入包时，会先调用包中的初始化函数，这种使用方式仅让导入的包做初始化，而不使用包中其他功能

## 19.goroutine 创建的时候如果要传入一个参数进去需要注意的点

1. 直接传递参数：在go关键字后面跟上函数名和参数。Go语言会自动复制这些值，因此传递的是值的副本，而不是引用。
2. 使用结构体：如果要传递多个参数，可以创建一个结构体来封装这些参数
3. 使用通道：如果希望在goroutine启动后还能继续与之通信，可以使用通道。在启动goroutine时，可以传递一个通道给它，然后在之后通过这个通道发送或接收数据。
4. 使用指针或引用类型：如果你希望goroutine能够修改传递给它的数据，你可以传递一个指针或者引用类型。
5. 注意并发安全：如果多个goroutine共享数据，确保数据访问是线程安全的。使用互斥锁（`sync.Mutex`）、原子操作（`sync/atomic`包）或其他同步机制来保证数据的一致性。

## 20.写go单元测试的规范

## 21.单步测试

https://www.jianshu.com/p/21ed30859d80

## 22.导入一个go的工程，有些依赖找不到，改怎么办

## 23.值拷贝、引用拷贝；深拷贝、浅拷贝；

map，slice，chan 是引用拷贝；引用拷贝 是 浅拷贝

其余的，都是 值拷贝；值拷贝 是 深拷贝

#### 深浅拷贝的本质区别：

是否真正获取对象实体，而不是引用

**深拷贝：**

拷贝的是数据本身，创造一个新的对象，并在内存中开辟一个新的内存地址，与原对象是完全独立的，不共享内存，修改新对象时不会影响原对象的值。释放内存时，也没有任何关联。

**值拷贝：**

接收的是  整个array的值拷贝，所以方法对array中元素的重新赋值不起作用。

**浅拷贝：**

拷贝的是数据地址，只复制指向的对象的指针，新旧对象的内存地址是一样的，修改一个另一个也会变。释放内存时，同时释放。

**引用拷贝：**

函数的引用拷贝与原始的引用指向同一个数组，所以对数组中元素的修改，是有效的

## 24.精通Golang项目依赖Go modules

## 25.多返回值怎么实现的

Go语言利用了函数调用栈来管理返回值。当一个函数声明了多个返回值时，Go运行时会在栈上为每个返回值分配空间。当函数执行完毕时，这些返回值会被放置在栈上的特定位置，然后被调用者捕获。

## 26.Go 语言中不同的类型如何比较是否相等

像 string，int，float interface 等可以通过 reflect.DeepEqual 和等于号进行比较，像 slice，struct，map 则一般使用 reflect.DeepEqual 来检测是否相等。

## 27.Go中init 函数的特征

init 函数的执行顺序遵顼以下几个规则：

1. **包级别的init函数：**
   * 在一个包中声明的所有init函数按照他们在源代码文件中出现的顺序执行；
   * 如果一个包中有多个源文件，那么先按照文件名的字典排序，然后在每个文件内部再按照iniit函数声明的顺序执行
2. **导入顺序：**
   - 包的`init`函数的执行顺序取决于它们被导入的顺序。即，如果包A导入了包B和C，那么B和C的`init`函数将在A的`init`函数之前执行，但是B和C之间的执行顺序取决于它们在A的`import`语句中的出现顺序。
3. **依赖关系**
   - 如果包B依赖于包C（即B导入了C），那么C的`init`函数会在B的`init`函数之前执行。
4. **main包的init函数**
   - 所有其他包的`init`函数在main包的`init`函数执行之前完成。这意味着main包的`init`函数是整个程序中最后执行的`init`函数。
5. **嵌套init函数**
   - 如果一个`init`函数内部调用了另一个`init`函数，那么被调用的`init`函数将立即执行，而不是等到所有同级的`init`函数执行完。

## 28.Go中 uintptr和 unsafe.Pointer 的区别

unsafe.Pointer 是通用指针类型，它不能参与计算，任何类型的指针都可以转化成 unsafe.Pointer，unsafe.Pointer 可以转化成任何类型的指针，uintptr 可以转换为 unsafe.Pointer，unsafe.Pointer 可以转换为 uintptr。uintptr 是指针运算的工具，但是它不能持有指针对象（意思就是它跟指针对象不能互相转换），unsafe.Pointer 是指针对象进行运算（也就是 uintptr）的桥梁。

## 29.Go程序如何优雅退出进程

1. 监控系统停止信号：syscall.SIGINT；syscall.SIGTERM
2. 使用通道：在主goroutine中创建通道，然后在需要停止程序时向这个通道发送一个值。所有监听这个通道的goroutine都会接收到这个信号，然后可以开始执行清理操作并退出。
3. 使用Context传递有截止时间或者取消功能的Context，然后将其传递给需要被取消的函数

## 30.指针和引用类型的相同点和不同点

在 Go 语言中，"指针" 和 "引用类型" 这两个概念在行为上有一些相似之处，但也存在明显的区别。下面分别阐述它们的相同点和不同点。

### 相同点

1. **间接访问**：无论是指针还是引用类型，都可以用来间接访问和修改内存中的数据。当你有一个指向数据的指针或引用类型的变量时，可以通过这个指针或引用来改变原数据，而不仅仅是查看它。

2. **避免复制**：使用指针和引用类型可以避免在函数调用或赋值时复制大量数据。这在处理大对象或复杂数据结构时尤其重要，因为复制可能会非常耗时和消耗资源。

### 不同点

1. **语法和概念**：
   - **指针**：在 Go 中，指针是一种基础类型，它存储的是另一个变量的内存地址。使用 `&` 运算符可以获取一个变量的地址，使用 `*` 运算符可以解引用指针，访问指针所指向的值。
   - **引用类型**：Go 中没有显式的 "引用" 类型的概念，但是某些类型（如切片、映射、接口、通道等）的行为类似于其他语言中的引用类型。当这些类型的变量被赋值或作为参数传递时，它们实际上传递的是对原始数据的引用，而不是数据的拷贝。

2. **行为差异**：
   - 对于指针，你直接处理内存地址。这意味着你必须显式地使用 `&` 和 `*` 运算符来获取地址和解引用。例如，要修改一个变量的值，你可能需要创建一个指向该变量的指针，然后通过解引用该指针来修改。
   - 对于引用类型，如切片或映射，你无需显式地使用指针运算符。当你将一个引用类型的变量赋值给另一个变量时，你实际上是在创建一个指向同一数据的新引用，而不是复制数据本身。这意味着对其中一个变量所做的任何更改都会反映在另一个变量上，因为它们共享相同的数据。

3. **初始化和生命周期**：
   - 指针可以指向任何类型的变量，但必须明确初始化为 `nil` 或指向一个有效的内存地址。
   - 引用类型（如切片和映射）在 Go 中通常通过 `make` 函数初始化，它们自动管理内存分配和释放，不需要手动解除引用或删除。

4. **用途和场景**：
   - 指针常用于需要直接控制内存访问和修改的场景，比如底层编程、性能敏感的代码或需要改变函数参数的值时。
   - 引用类型则更多地用于高级抽象，如动态数据结构的构建和管理，以及实现面向对象的风格或模式，如接口的实现和多态。

总结来说，Go 中的指针提供了底层的内存访问能力，而引用类型则提供了更高级、更安全的抽象层次，用于构建复杂的程序结构和数据管理。两者在不同的场景下都有其独特的作用和优势。

## 31、sync包有哪些东西

Go语言的`sync`包提供了用于解决并发问题的同步原语，帮助开发者在多线程环境下编写安全、高效的代码。以下是`sync`包中一些主要的组件和功能：

1. **Mutex** (`sync.Mutex`)
   - 互斥锁，用于保护对共享资源的并发访问。在多个goroutine之间提供独占访问。

2. **RWMutex** (`sync.RWMutex`)
   - 读写互斥锁，允许多个读操作同时进行，但写操作是独占的。适用于读多写少的场景。

3. **Once** (`sync.Once`)
   - 确保某个函数仅被调用一次，即使有多个goroutine同时调用。常用于初始化操作。

4. **WaitGroup** (`sync.WaitGroup`)
   - 等待一组并发操作完成。`Add`, `Done`, 和 `Wait` 方法用于管理和同步goroutine。

5. **Cond** (`sync.Cond`)
   - 条件变量，用于等待特定条件满足。常用于更复杂的同步逻辑，如生产者-消费者模型。

6. **Pool** (`sync.Pool`)
   - 对象池，用于重用昂贵的对象，减少分配和垃圾回收的压力。自Go 1.12起，`sync.Pool`被正式文档化。

7. **Map** (`sync.Map`)
   - 线程安全的映射类型，提供并发安全的键值存储。自Go 1.9起引入，用于替代非线程安全的map。

8. **Atomic** (`sync/atomic`)
   - 提供原子操作，如`AtomicAddInt64`和`AtomicSwapInt64`，用于在无需锁的情况下更新整数和指针类型的变量。

9. **Barrier** (`sync.Barrier`)
   - 同步屏障，用于同步一组goroutine在某个点的进度。自Go 1.17起引入。

10. **Mutex和RWMutex的Lock/LockOSThread/Unlock/UnlockOSThread**
    - 锁定和解锁方法，用于控制对共享资源的访问。

11. **NewMutex/Locker/NewRLocker**
    - 创建锁的工厂函数，用于封装锁逻辑。

12. **Pool的New**
    - 创建一个新的对象池。

13. **Map的Load/Store/Delete/Range**
    - 提供线程安全的map操作，如加载、存储、删除和遍历键值对。

`sync`包中的这些工具和结构共同构成了Go语言中处理并发和同步问题的基础，使开发者能够编写出高效且安全的并发程序。使用这些同步原语，可以有效地避免竞态条件、死锁和其他并发问题。

## 32、值类型和引用类型

### 值类型：

基本数据类型都是值类型，包括：int系列，float 系列，bool，string，数组，结构体struct

### 引用类型

指针、切片Slice、接口interface、管道 channel以及 map

### 值类型与引用类型的区别

值类型在内存种存储的是值本身，而引用类型在内存中存储的是值的内存地址。

值类型内存通常在栈中分配，引用类型内存通常在堆中分配。

# 02-slice

## 1.数组和切片的区别

**相同点：**

1)只能存储一组相同类型的数据结构

2)都是通过下标来访问，并且有容量长度，长度通过 len 获取，容量通过 cap 获取

**区别：**

1）数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容

2）数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变

**简洁的回答：**

1）定义方式不一样 2）初始化方式不一样，数组需要指定大小，大小不改变 3）在函数传递中，数组切片都是值传递。

**数组的定义**

var a1 [3]int

var a2 [...]int{1,2,3}

**切片的定义**

var a1 []int

var a2 :=make([]int,3,5)

**数组的初始化**

a1 := [...]int{1,2,3}

a2 := [5]int{1,2,3}

**切片的初始化**

b:= make([]int,3,5)

## 2.讲讲Go的slice底层数据结构和一些特性

### 底层结构：

* **指向底层数组的指针：可以访问和操作数组元素**
* **长度**：表示slice 当前包含的元素数量
* **容量**：表示slice可以从底层数组中访问的最大元素数量。

### 内存分配增长

1.18之后，Go1.18不再以1024为临界点，而是设定了一个值为256的threshold，以256为临界点；超过256，不再是每次扩容1/4，而是每次增加（旧容量+3*256）/4；其中cap为预期容量，也就是说添加了数据之后需要的容量

当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容；当原 slice 容量 < threshold 的时候，新 slice 容量变成原来的 2 倍；
当原 slice 容量 > threshold，进入一个循环，每次容量增加（旧容量+3*threshold）/4

### 切片操作

```
s := []int{1, 2, 3, 4, 5}
s1 := s[1:3] // s1 是 [2, 3]
s2 := s[:3]  // s2 是 [1, 2, 3]
s3 := s[2:]  // s3 是 [3, 4, 5]
```



## 3.golang中数组和slice作为参数的区别slice作为参数传递有什么问题

1. 当使用数组作为参数和返回值的时候，传进去的是值，在函数内部对数组进行修改并不会影响原数据
2. 当切片作为参数的时候穿进去的是值，也就是值传递，但是当我在函数里面修改切片的时候，我们发现源数据也会被修改，这是因为我们在切片的底层维护这一个匿名的数组，当我们把切片当成参数的时候，会重现创建一个切片，但是创建的这个切片和我们原来的数据是共享数据源的，所以在函数内被修改，源数据也会被修改
3. 数组还是切片，在函数中传递的时候如果没有指定为指针传递的话，都是值传递，但是切片在传递的过程中，有着共享底层数组的风险，所以如果在函数内部进行了更改的时候，会修改到源数据，所以我们需要根据不同的需求来处理，如果我们不希望源数据被修改话的我们可以使用copy函数复制切片后再传入，如果希望源数据被修改的话我们应该使用指针传递的方式

## 4.从数组中取一个相同大小的slice有成本吗&从切片中取一个相同大小的数组有成本吗

### 从数组中去一个相同大小的slice

当从数组中创建一个相同大小的切片时，成本主要是创建新的切片头结构（slice header），即分配一段内存来存储切片的指针、长度和容量。由于Go的切片结构相对较小（一般只有三个指针或整型字段），这个成本通常是可以接受的，并且不涉及数据复制。**新切片将引用原数组的相同内存区域，直到数组或切片被改变或切片被重新分配。**

### 从切片中取一个相同大小的数组

从切片中创建一个相同大小的数组则涉及数据复制的成本。这是因为Go中的数组是固定大小的，且必须连续存储在内存中。当你从切片中取出一个相同大小的数组时，Go运行时必须为数组分配一块连续的内存空间，并将切片中的元素复制到这块新空间中。这个复制操作的成本与数组的大小成正比。

## 5.数组与切片有什么异同

slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。

数组是定长的，长度定义好之后，不能再更改。**在 Go 中，数组是不常见的，因为其长度是类型的一部分**，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。

而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。

数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。

```go
// runtime/slice.go
type slice struct {
	array unsafe.Pointer // 元素指针
	len   int // 长度 
	cap   int // 容量
}
```

slice 的数据结构如下：

![切片数据结构](E:/Typora%20picture/0-17219209364781.png)

注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。

【引申1】 [3]int 和 [4]int 是同一个类型吗？

**不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。**

【引申2】 下面的代码输出是什么？

说明：例子来自雨痕大佬《Go学习笔记》第四版，P43页。这里我会进行扩展，并会作图详细分析。

```go
package main

import "fmt"

func main() {
	slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s1 := slice[2:5]
	s2 := s1[2:6:7]

	s2 = append(s2, 100)
	s2 = append(s2, 200)

	s1[2] = 20

	fmt.Println(s1)
	fmt.Println(s2)
	fmt.Println(slice)
}
```

结果：

```
[2 3 20]
[4 5 6 7 100 200]
[0 1 2 3 20 4 5 6 100 9]
```

`s1` 从 `slice` 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。 `s2` 从 `s1` 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。

![slice origin](E:/Typora%20picture/1-17219209364783.png)

接着，向 `s2` 尾部追加一个元素 100：

```go
s2 = append(s2, 100)
```

`s2` 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 `s1` 都可以看得到。

![append 100](E:/Typora%20picture/2-17219209364785.png)

再次向 `s2` 追加元素200：

```
s2 = append(s2, 200)
```

这时，`s2` 的容量不够用，该扩容了。于是，`s2` 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 `append` 带来的再一次扩容，`s2` 会在此次扩容的时候多留一些 `buffer`，将新的容量将扩大为原始容量的2倍，也就是10了。

![append 200](E:/Typora%20picture/3-17219209364787.png)

最后，修改 `s1` 索引为2位置的元素：

```go
s1[2] = 20
```

这次只会影响原始数组相应位置的元素。它影响不到 `s2` 了，人家已经远走高飞了。

![s1[2]=20](E:/Typora%20picture/4-17219209364789.png)

再提一点，打印 `s1` 的时候，只会打印出 `s1` 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。

## 6.切片的容量是怎样增长的

一般都是在向 slice 追加了元素之后，才会引起扩容。追加元素调用的是 `append` 函数。

先来看看 `append` 函数的原型：

```go
func append(slice []Type, elems ...Type) []Type
```

append 函数的参数长度可变，因此可以追加多个值到 slice 中，还可以用 `...` 传入 slice，直接追加一个切片。

```go
slice = append(slice, elem1, elem2)
slice = append(slice, anotherSlice...)
```

`append`函数返回值是一个新的slice，Go编译器不允许调用了 append 函数后不使用返回值。

```go
append(slice, elem1, elem2)
append(slice, anotherSlice...)
```

所以上面的用法是错的，不能编译通过。

使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 `len-1` 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。

这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 `slice` 的容量是留了一定的 `buffer` 的。否则，每次添加元素的时候，都会发生迁移，成本太高。

新 slice 预留的 `buffer` 大小是有一定规律的。在golang1.18版本更新之前网上大多数的文章都是这样描述slice的扩容策略的：

> 当原 slice 容量小于 `1024` 的时候，新 slice 容量变成原来的 `2` 倍；原 slice 容量超过 `1024`，新 slice 容量变成原来的`1.25`倍。

在1.18版本更新之后，slice的扩容策略变为了：

> 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4

为了说明上面的规律，我写了一小段玩具代码：

```go
package main

import "fmt"

func main() {
	s := make([]int, 0)

	oldCap := cap(s)

	for i := 0; i < 2048; i++ {
		s = append(s, i)

		newCap := cap(s)

		if newCap != oldCap {
			fmt.Printf("[%d -> %4d] cap = %-4d  |  after append %-4d  cap = %-4d\n", 0, i-1, oldCap, i, newCap)
			oldCap = newCap
		}
	}
}
```

我先创建了一个空的 `slice`，然后，在一个循环里不断往里面 `append` 新的元素。然后记录容量的变化，并且每当容量发生变化的时候，记录下老的容量，以及添加完元素之后的容量，同时记下此时 `slice` 里的元素。这样，我就可以观察，新老 `slice` 的容量变化情况，从而找出规律。

运行结果(1.18版本之前)：

```
[0 ->   -1] cap = 0     |  after append 0     cap = 1   
[0 ->    0] cap = 1     |  after append 1     cap = 2   
[0 ->    1] cap = 2     |  after append 2     cap = 4   
[0 ->    3] cap = 4     |  after append 4     cap = 8   
[0 ->    7] cap = 8     |  after append 8     cap = 16  
[0 ->   15] cap = 16    |  after append 16    cap = 32  
[0 ->   31] cap = 32    |  after append 32    cap = 64  
[0 ->   63] cap = 64    |  after append 64    cap = 128 
[0 ->  127] cap = 128   |  after append 128   cap = 256 
[0 ->  255] cap = 256   |  after append 256   cap = 512 
[0 ->  511] cap = 512   |  after append 512   cap = 1024
[0 -> 1023] cap = 1024  |  after append 1024  cap = 1280
[0 -> 1279] cap = 1280  |  after append 1280  cap = 1696
[0 -> 1695] cap = 1696  |  after append 1696  cap = 2304
```

运行结果(1.18版本)：

```
[0 ->   -1] cap = 0     |  after append 0     cap = 1
[0 ->    0] cap = 1     |  after append 1     cap = 2   
[0 ->    1] cap = 2     |  after append 2     cap = 4   
[0 ->    3] cap = 4     |  after append 4     cap = 8   
[0 ->    7] cap = 8     |  after append 8     cap = 16  
[0 ->   15] cap = 16    |  after append 16    cap = 32  
[0 ->   31] cap = 32    |  after append 32    cap = 64  
[0 ->   63] cap = 64    |  after append 64    cap = 128 
[0 ->  127] cap = 128   |  after append 128   cap = 256 
[0 ->  255] cap = 256   |  after append 256   cap = 512 
[0 ->  511] cap = 512   |  after append 512   cap = 848 
[0 ->  847] cap = 848   |  after append 848   cap = 1280
[0 -> 1279] cap = 1280  |  after append 1280  cap = 1792
[0 -> 1791] cap = 1792  |  after append 1792  cap = 2560
```

根据上面的结果我们可以看出在`1.18`版本之前：

在原来的slice容量`oldcap`小于1024的时候，新 slice 的容量`newcap`的确是`oldcap`的2倍。

但是，当`oldcap`大于等于 `1024` 的时候，情况就有变化了。当向 slice 中添加元素 `1280` 的时候，原来的slice 的容量为 `1280`，之后`newcap`变成了 `1696`，两者并不是 `1.25` 倍的关系（1696/1280=1.325）。添加完 `1696` 后，新的容量 `2304` 当然也不是 `1696` 的 `1.25` 倍。

在`1.18`版本之后：

在原来的slice 容量`oldcap`小于256的时候，新 slice 的容量`newcap`的确是`oldcap` 的2倍。

但是，当`oldcap`容量大于等于 `256` 的时候，情况就有变化了。当向 slice 中添加元素 `512` 的时候，老 slice 的容量为 `512`，之后变成了 `8`48，两者并没有符合`newcap = oldcap+(oldcap+3*256)/4` 的策略（512+（512+3*256）/4）=832。添加完 `848` 后，新的容量 `1280` 当然也不是 按照之前策略所计算出的的1252。

难道现在网上各种文章中的扩容策略并不是正确的吗。我们直接搬出源码：源码面前，了无秘密。

从前面汇编代码我们也看到了，向 slice 追加元素的时候，若容量不够，会调用 `growslice` 函数，所以我们直接看它的代码。

**golang版本1.9.5**

```go
// go 1.9.5 src/runtime/slice.go:82
func growslice(et *_type, old slice, cap int) slice {
    // ……
    newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		if old.len < 1024 {
			newcap = doublecap
		} else {
			for newcap < cap {
				newcap += newcap / 4
			}
		}
	}
	// ……
	
	capmem = roundupsize(uintptr(newcap) * ptrSize)
	newcap = int(capmem / ptrSize)
}
```

**golang版本1.18**

```go
// go 1.18 src/runtime/slice.go:178
func growslice(et *_type, old slice, cap int) slice {
    // ……
    newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		const threshold = 256
		if old.cap < threshold {
			newcap = doublecap
		} else {
			for 0 < newcap && newcap < cap {
                // Transition from growing 2x for small slices
				// to growing 1.25x for large slices. This formula
				// gives a smooth-ish transition between the two.
				newcap += (newcap + 3*threshold) / 4
			}
			if newcap <= 0 {
				newcap = cap
			}
		}
	}
	// ……
    
	capmem = roundupsize(uintptr(newcap) * ptrSize)
	newcap = int(capmem / ptrSize)
}
```

看到了吗？如果只看前半部分，现在网上各种文章里说的 `newcap` 的规律是对的。现实是，后半部分还对 `newcap` 作了一个`内存对齐`，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 `大于等于` 按照前半部分生成的`newcap`。

之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。

最后，向 `growslice` 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。

【引申1】

来看一个例子，来源于[这里](https://jiajunhuang.com/articles/2017_07_18-golang_slice.md.html)

```go
package main

import "fmt"

func main() {
    s := []int{5}
    s = append(s, 7)
    s = append(s, 9)
    x := append(s, 11)
    y := append(s, 12)
    fmt.Println(s, x, y)
}
```

| 代码               | 切片对应状态                                                 |
| ------------------ | ------------------------------------------------------------ |
| s := []int{5}      | s 只有一个元素，`[5]`                                        |
| s = append(s, 7)   | s 扩容，容量变为2，`[5, 7]`                                  |
| s = append(s, 9)   | s 扩容，容量变为4，`[5, 7, 9]`。注意，这时 s 长度是3，只有3个元素 |
| x := append(s, 11) | 由于 s 的底层数组仍然有空间，因此并不会扩容。这样，底层数组就变成了 `[5, 7, 9, 11]`。注意，此时 s = `[5, 7, 9]`，容量为4；x = `[5, 7, 9, 11]`，容量为4。这里 s 不变 |
| y := append(s, 12) | 这里还是在 s 元素的尾部追加元素，由于 s 的长度为3，容量为4，所以直接在底层数组索引为3的地方填上12。结果：s = `[5, 7, 9]`，y = `[5, 7, 9, 12]`，x = `[5, 7, 9, 12]`，x，y 的长度均为4，容量也均为4 |

所以最后程序的执行结果是：

```
[5 7 9] [5 7 9 12] [5 7 9 12]
```

这里要注意的是，append函数执行完后，返回的是一个全新的 slice，并且对传入的 slice 并不影响。

【引申2】

关于 `append`，我们最后来看一个例子，来源于 [Golang Slice的扩容规则](https://jodezer.github.io/2017/05/golangSlice的扩容规则)。

```go
package main

import "fmt"

func main() {
	s := []int{1,2}
	s = append(s,4,5,6)
	fmt.Printf("len=%d, cap=%d",len(s),cap(s))
}
```

运行结果是：

```go
len=5, cap=6
```

如果按网上各种文章中总结的那样：小于原 slice 长度小于 1024 的时候，容量每次增加 1 倍。添加元素 4 的时候，容量变为4；添加元素 5 的时候不变；添加元素 6 的时候容量增加 1 倍，变成 8。

那上面代码的运行结果就是：

```go
len=5, cap=8
```

这是错误的！我们来仔细看看，为什么会这样，再次搬出代码：

```go
// go 1.9.5 src/runtime/slice.go:82
func growslice(et *_type, old slice, cap int) slice {
    // ……
    newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		// ……
	}
	// ……
	
	capmem = roundupsize(uintptr(newcap) * ptrSize)
	newcap = int(capmem / ptrSize)
}
```

这个函数的参数依次是 `元素的类型，老的 slice，新 slice 最小求的容量`。

例子中 `s` 原来只有 2 个元素，`len` 和 `cap` 都为 2，`append` 了三个元素后，长度变为 5，容量最小要变成 5，即调用 `growslice` 函数时，传入的第三个参数应该为 5。即 `cap=5`。而一方面，`doublecap` 是原 `slice`容量的 2 倍，等于 4。满足第一个 `if` 条件，所以 `newcap` 变成了 5。

接着调用了 `roundupsize` 函数，传入 40。（代码中ptrSize是指一个指针的大小，在64位机上是8）

我们再看内存对齐，搬出 `roundupsize` 函数的代码：

```go
// src/runtime/msize.go:13
func roundupsize(size uintptr) uintptr {
	if size < _MaxSmallSize {
		if size <= smallSizeMax-8 {
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
		} else {
			//……
		}
	}
    //……
}

const _MaxSmallSize = 32768
const smallSizeMax = 1024
const smallSizeDiv = 8
```

很明显，我们最终将返回这个式子的结果：

```
class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]]
```

这是 `Go` 源码中有关内存分配的两个 `slice`。`class_to_size`通过 `spanClass`获取 `span`划分的 `object`大小。而 `size_to_class8` 表示通过 `size` 获取它的 `spanClass`。

```go
var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32}
var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}
```

我们传进去的 `size` 等于 40。所以 `(size+smallSizeDiv-1)/smallSizeDiv = 5`；获取 `size_to_class8` 数组中索引为 `5` 的元素为 `5`；获取 `class_to_size` 中索引为 `5` 的元素为 `48`。

最终，新的 slice 的容量为 `6`：

```go
newcap = int(capmem / ptrSize) // 6
```

至于，上面的两个`魔法数组`的由来，就不展开了。

【引申2】 向一个nil的slice添加元素会发生什么？为什么？

其实 `nil slice` 或者 `empty slice` 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 `mallocgc` 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的`nil slice` 或 `empty slice`，然后摇身一变，成为“真正”的 `slice` 了。

## 7.切片作为函数参数

slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址。

当 slice 作为函数参数时，就是一个普通的结构体。其实很好理解：若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作改变；若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。

**值得注意的是，不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据。**为什么能改变底层数组的数据？很好理解：底层数据在 slice 结构体里是一个指针，尽管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据，没有问题。

通过 slice 的 array 字段就可以拿到数组的地址。在代码里，是直接通过类似 `s[i]=10` 这种操作改变 slice 底层数组元素值。

另外，值得注意的是，**Go 语言的函数参数传递，只有值传递，没有引用传递。**

来看一个代码片段：

```go
package main

func main() {
	s := []int{1, 1, 1}
	f(s)
	fmt.Println(s)
}

func f(s []int) {
	// i只是一个副本，不能改变s中元素的值
	/*for _, i := range s {
		i++
	}
	*/

	for i := range s {
		s[i] += 1
	}
}
```

运行一下，程序输出：

```go
[2 2 2]
```

果真改变了原始 slice 的底层数据。这里传递的是一个 slice 的副本，在 `f` 函数中，`s` 只是 `main` 函数中 `s` 的一个拷贝。在`f` 函数内部，对 `s` 的作用并不会改变外层 `main` 函数的 `s`。

要想真的改变外层 `slice`，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针。我们再来看一个例子：

```go
package main

import "fmt"

func myAppend(s []int) []int {
	// 这里 s 虽然改变了，但并不会影响外层函数的 s
	s = append(s, 100)
	return s
}

func myAppendPtr(s *[]int) {
	// 会改变外层 s 本身
	*s = append(*s, 100)
	return
}

func main() {
	s := []int{1, 1, 1}
	newS := myAppend(s)

	fmt.Println(s)
	fmt.Println(newS)

	s = newS

	myAppendPtr(&s)
	fmt.Println(s)
}
```

运行结果：

```
[1 1 1]
[1 1 1 100]
[1 1 1 100 100]
```

`myAppend` 函数里，虽然改变了 `s`，但它只是一个值传递，并不会影响外层的 `s`，因此第一行打印出来的结果仍然是 `[1 1 1]`。

而 `newS` 是一个新的 `slice`，它是基于 `s` 得到的。因此它打印的是追加了一个 `100` 之后的结果： `[1 1 1 100]`。

最后，将 `newS` 赋值给了 `s`，`s` 这时才真正变成了一个新的slice。之后，再给 `myAppendPtr` 函数传入一个 `s 指针`，这回它真的被改变了：`[1 1 1 100 100]`。

# 03-map

## 1.map使用注意的点，是否并发安全

map的类型是map[key]，key类型的ke必须是可比较的，通常情况，会选择内建的基本类型，比如整数、字符串做key的类型。如果要使用struct作为key，**要保证struct对象在逻辑上是不可变的**。在Go语言中，map[key]函数返回结果可以是一个值，也可以是两个值。map是无序的，如果我们想要保证遍历map时元素有序，可以使用辅助的数据结构，例如orderedmap。

**第一，**一定要先初始化，否则panic

**第二，**map类型是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的panic。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。

## 2.map循环是有序的还是无序的

无序的，**map因扩张⽽重新哈希时，各键值项存储位置都可能会发生改变，顺序自然也没法保证了**，所以官方避免大家依赖顺序，直接打乱处理。就是 for range map 在开始处理循环逻辑的时候，就做了随机播种

## 3.map 中删除一个key，它的内存会释放吗

map 删除一个键：

```
m := map[string]int{"a": 1, "b": 2}
delete(m, "a") // 删除键"a"，其对应的值1将被释放
```

使用 `delete` 函数可以从 `map` 中删除一个键，并且与该键关联的值也会被删除。这有可能导致内存被释放，但实际情况取决于 Go 的垃圾回收器（Garbage Collector）。

当你使用 `delete` 函数删除一个键时，这个键及其关联的值会从 `map` 中移除，这样，**如果没有其他的引用指向这个值，那么这个值就成为了垃圾，等待垃圾回收器进行回收。**

虽然 `delete` 可以从 `map` 中删除键，**但它不会缩小或重新分配 `map` 的底层存储。也就是说，即使你删除了许多键，`map` 本身占用的内存也不会立即减小。**这是因为 `map` 的设计目的是为了优化访问速度，而不是空间效率。

如果你需要释放大量的 `map` 内存，一种方法是创建一个新的 `map`，并将旧 `map` 中你想保留的元素复制过去，然后让旧 `map` 变成垃圾，等待垃圾回收器回收。这样可以有效地释放内存，但也会带来一定的性能开销。

## 4.怎么处理对map进行并发访问有没有其他方案区别是什么

方式一、使用内置sync.Map 

方式二、使用读写互斥锁 sync.RWMutex 

```go
import "sync"

var rwmu sync.RWMutex
var m = make(map[string]int)

func updateMap(key string, value int) {
    rwmu.Lock()
    defer rwmu.Unlock()
    m[key] = value
}

func readMap(key string) (int, bool) {
    rwmu.RLock()
    defer rwmu.RUnlock()
    val, ok := m[key]
    return val, ok
}
```

方式三、使用原子操作

方式四、使用Channel进行同步

## 5.nil map和空 map有何不同

1. 可以对未初始化的map进行取值，但取出来的东西是空

2. 不能对未初始化的map进行赋值，这样会抛出异常

   未初始化的map是nil，它与一个空map基本等价，只是nil的map不允许往里面添加值。

   ```
   var m1 map[string]string
   m1["1"] = "1"
   panic: assignment to entry in nil map
   
   因此，map是nil时，取值是不会报错的（取不到而已），但增加值会报错。
   ```

3. 通过fmt打印map时，空map和nil map结果是一样的，都为map[]。所以，这个时候别断定map是空还是nil，而应该通过map == nil来判断。

## 6.map的数据结构是什么

### 1.map数据结构

Golang的map使用哈希表作为底层实现，**一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。**

map数据结构由`runtime/map.go:hmap`定义:

```
type hmap struct {
    count     int // 当前保存的元素个数
    ...
    B         uint8
    ...
    buckets    unsafe.Pointer // bucket数组指针，数组的大小为2^B
    ...
}
```

下图展示一个拥有4个bucket的map：

![null](E:/Typora%20picture/m_897a05f6373f7f966d00d1bfea6274d2_r.png)

本例中, `hmap.B=2`， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。

`bucket`很多时候被翻译为桶，所谓的`哈希桶`实际上就是bucket。

### 2.bucket数据结构

bucket数据结构由`runtime/map.go:bmap`定义：

```go
type bmap struct {
    tophash [8]uint8 //存储哈希值的高8位
    data    byte[1]  //key value数据:key/key/key/.../value/value/value...
    overflow *bmap   //溢出bucket的地址
}
```

每个bucket可以存储8个键值对。

- tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。
- data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。
- overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。

注意：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。

下图展示bucket存放8个key-value对：

![null](E:/Typora%20picture/m_7f0ba5a124641b1413279892581513c4_r.png)

### 3.哈希冲突

当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。
由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。

下图展示产生冲突后的map：

![null](E:/Typora%20picture/m_a8b9e5919d9951a71c1c36445dd68521_r.png)

bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍。

### 4.负载因子

负载因子用于衡量一个哈希表冲突情况，公式为：

```go
负载因子 = 键数量/bucket数量
```

例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.

哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：

- 哈希因子过小，说明空间利用率低
- 哈希因子过大，说明冲突严重，存取效率低

每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。

## 7.map是怎么实现扩容

为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。
触发扩容的条件有二个：

1. 负载因子 > 6.5时，也即平均每个bucket存储的键值对达到6.5个。
2. overflow数量 > 2^15时，也即overflow数量超过32768时。

### 7.1、增量扩容

当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。
考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。

下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):

![null](E:/Typora%20picture/m_2d622a6bc19ca1b5bcb225f77869f9c2_r.png)

当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。

当第8个键值对插入时，将会触发扩容，扩容后示意图如下：

![null](E:/Typora%20picture/m_2f0122f26e5d66ca91e6820ace6b379b_r.png)

hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。
后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。

搬迁完成后的示意图如下：

![null](E:/Typora%20picture/m_b1178e0a3cea02c9386e5f5eaa6f99a6_r.png)

数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。
实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。

### 7.2、等量扩容

所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。
在极端场景下，比如不断地增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：

![null](E:/Typora%20picture/m_f3a5989c90204df9304d5ae246f3db72_r.png)

上图可见，overflow的bucket中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。

## 8.查找过程

查找过程如下：

1. 根据key值算出哈希值
2. 取哈希值低位与hmap.B取模确定bucket位置
3. 取哈希值高位在tophash数组中查询
4. 如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较
5. 当前bucket没有找到，则继续从下个overflow的bucket中查找。
6. 如果当前处于搬迁过程，则优先从oldbuckets查找

注：如果查找不到，也不会返回空值，而是返回相应类型的0值。

## 9.插入过程

新元素插入过程如下：

1. 根据key值算出哈希值
2. 取哈希值低位与hmap.B取模确定bucket位置
3. 查找该key是否已经存在，如果存在则直接更新值
4. 如果没找到将key，将key插入

## 10.slices 能作为map类型的key吗

**在golang规范中，可比较的类型都可以作为map key；**这个问题又延伸到在：golang规范中，哪些数据类型可以比较？

| 类型            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| bool 布尔值     |                                                              |
| numeric 数字    | 包括整型、浮点型以及复数                                     |
| string 字符串   |                                                              |
| pointer 指针    | 两个指针类型相等，表示两指针指向同一个变量或者同为nil        |
| channel 通道    | 两个通道类型相等，表示两个通道是被相同的make调用创建的或者同为nil |
| interface 接口  | 两个接口类型相等，表示两个接口类型 的动态类型 和 动态值都相等 或者 两接口类型 同为 nil |
| structs、arrays | 只包含以上类型元素                                           |

**不能作为map key 的类型包括：**

- slices
- maps
- functions

## 11.map的实现原理

## 12.如何实现两种get操作

## 13.遍历过程

## 14.赋值过程

## 15.删除过程

## 16.扩容过程

## 17.key为什么是无序的

## 18.float类型可以作为map的key吗

## 19.可以边遍历边删除吗

## 20.可以对map的元素取地址吗

## 21.如何比较两个map相等

## 22.map 是线程安全的吗



# 04-接口

## 1.Go语言与鸭子类型的关系

总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它"当前方法和属性的集合"决定。Go 作为一种静态语言，通过接口实现了 鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。

## 2.值接收者和指针接收者的区别

#### 方法

方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。

在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。

也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。

实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：

| **-**          | **值接收者**                                                 | **指针接收者**                                               |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 值类型调用者   | 方法会使用调用者的一个副本，类似于“传值”                     | 使用值的引用来调用方法，上例中，qcrao.growUp() 实际上是 (&qcrao).growUp() |
| 指针类型调用者 | 指针被解引用为值，上例中，stefno.howOld() 实际上是 (*stefno).howOld() | 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针 |

#### 值接收者和指针接收者

前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。

先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。

所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。

最后，只要记住下面这点就可以了：

如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。

#### 两者分别在何时使用

如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。

使用指针作为方法的接收者的理由：

- 方法能够修改接收者指向的值。
- 避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。

是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。

如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。

如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。

## 3.iface和eface的区别是什么

iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{}。

从源码层面看一下：

```plain
type iface struct {
    tab  *itab
    data unsafe.Pointer
}

type itab struct {
    inter  *interfacetype
    _type  *_type
    link   *itab
    hash   uint32 // copy of _type.hash. Used for type switches.
    bad    bool   // type does not implement interface
    inhash bool   // has this itab been added to hash?
    unused [2]byte
    fun    [1]uintptr // variable sized
}
```

iface 内部维护两个指针，tab 指向一个 itab 实体， 它表示接口的类型以及赋给这个接口的实体类型。data 则指向接口具体的值，一般而言是一个指向堆内存的指针。

再来仔细看一下 itab 结构体：_type 字段描述了实体的类型，包括内存对齐方式，大小等；inter 字段则描述了接口的类型。fun 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。

这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。

另外，你可能会觉得奇怪，为什么 fun 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。

再看一下 interfacetype 类型，它描述的是接口的类型：

```plain
type interfacetype struct {
    typ     _type
    pkgpath name
    mhdr    []imethod
}
```

可以看到，它包装了 _type 类型，_type 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 mhdr 字段，表示接口所定义的函数列表， pkgpath 记录定义了接口的包名。

这里通过一张图来看下 iface 结构体的全貌：

![img](E:/Typora%20picture/1671113733638-8e2e9037-11a8-49af-8dd3-dfd37d7f5d21.png)

接着来看一下 eface 的源码：

```plain
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
```

相比 iface，eface 就比较简单了。只维护了一个 _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值。

![img](E:/Typora%20picture/1671113735267-6bcdb7c8-dd73-432c-b933-d218fc1b7480.png)

## 4.接口的动态类型和动态值

从源码里可以看到：iface包含两个字段：tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动态值。而接口值包括动态类型和动态值。

【引申1】接口类型和 nil 作比较

接口值的零值是指动态类型和动态值都为 nil。当仅且当这两部分的值都为 nil 的情况下，这个接口值就才会被认为 接口值 == nil。

## 5.编译器自动检测类型是否实现接口

## 6.接口的构造过程是怎样的

## 7.类型转换和断言的区别

我们知道，Go 语言中不允许隐式类型转换，也就是说 = 两边，不允许出现类型不相同的变量。

类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。

#### **类型转换**

对于类型转换而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：

<结果类型> := <目标类型> ( <表达式> )

```plain
func main() {
    var i int = 9

    var f float64
    f = float64(i)
    fmt.Printf("%T, %v\n", f, f)

    f = 10.8
    a := int(f)
    fmt.Printf("%T, %v\n", a, a)
}
```

#### 断言

前面说过，因为空接口 interface{} 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。

断言的语法为：

<目标类型的值>，<布尔参数> := <表达式>.( 目标类型 ) // 安全类型断言 

<目标类型的值> := <表达式>.( 目标类型 ) //非安全类型断言

类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。

```plain
type Student struct {
    Name string
    Age int
}

func main() {
    var i interface{} = new(Student)
    s, ok := i.(Student)
    if ok {
        fmt.Println(s)
    }
}
```

断言其实还有另一种形式，就是用在利用 switch 语句判断接口的类型。每一个 case 会被顺序地考虑。当命中一个 case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case 匹配的情况。

## 8.接口转换的原理

通过前面提到的 iface 的源码可以看到，实际上它包含接口的类型 interfacetype 和 实体类型的类型 _type，这两者都是 iface 的字段 itab 的成员。也就是说生成一个 itab 同时需要接口的类型和实体的类型。

<interface 类型， 实体类型> ->itable

当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。

例如某类型有 m 个方法，某接口有 n 个方法，则很容易知道这种判定的时间复杂度为 O(mn)，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 O(m+n)。

这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。

1. 具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。
2. 具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。
3. 而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。

## 9.如何用interface实现多态

## 10.Go 接口与C++接口有何异同



# 05-context

## 1.context结构是什么样的

context包的主要结构体和接口包括：

* **Context 接口**：实现了四个方法：`Done() <- chan struct{}`；`Err() error`；`Deadline() (deadline time.Time, ok bool)`；`Value(key interface{}) interface{}`
* **BaseContext结构体**；通常是 `Background`、`TODO` 上下文类型
* **CancelFunc函数类型**：当被调用时会取消一个上下文。它是 `WithCancel`, `WithDeadline` 和 `WithTimeout` 函数返回的第二个值。
* **derivedCtx 结构体**：`derivedCtx` 是所有派生上下文的基类，它持有对父上下文的引用和一些额外的字段。派生上下文包括通过 `WithCancel`, `WithDeadline` 和 `WithTimeout` 创建的上下文。
* **timerCtx 结构体**：`timerCtx` 是用于带有截止时间的上下文的类型，它包含一个定时器，用于在到达截止时间时关闭 `Done` 通道。
* **cancelCtx 结构体**：`cancelCtx` 是用于带有取消功能的上下文的类型，它包含一个无缓冲的通道 `done` 和一个 `children` 字段，用于跟踪所有子上下文。当 `cancelCtx` 被取消时，它会关闭 `done` 通道，并通知所有子上下文。
* **valueCtx 结构体**：`valueCtx` 是用于携带值的上下文的类型，它包含一个键值对，用于在上下文中传递数据。
* **emptyCtx 结构体**：`emptyCtx` 是一个特殊的 `Context` 实现，用于 `Background` 和 `TODO` 上下文。它是最简单的 `Context` 实现，不包含任何额外的状态。

## 2.context使用场景和用途

### 使用场景：

1. 跨API边界和goroutine 通信：当一个 HTTP 请求进入 web 服务器，可以创建一个 `context` 并将其传递给处理该请求的所有 goroutines。这样，如果请求被取消或超时，所有相关 goroutines 都可以接收到这个信号并停止其工作。
2. 超时控制：  对于可能需要很长时间才能完成的 I/O 操作或远程调用，可以使用 `context.WithTimeout` 或 `context.WithDeadline` 来创建一个带有限定时间的 `context`。一旦超时，所有使用该 `context` 的 goroutines 都会被通知并停止等待。
3. 取消操作 ：使用 `context.WithCancel` 可以创建一个可取消的 `context`。这在需要能够响应外部信号（如用户取消操作）的场景中非常有用。
4. 传递请求范围的数据： `context` 允许在请求的生命周期内传递数据，而不必在函数签名中显式传递。这对于日志记录、身份验证信息或追踪 ID 等数据特别有用。
5. 资源管理： `context` 可以用于协调资源的释放。例如，当 `context` 被取消时，所有相关 goroutines 可以释放它们占用的资源。
6. **测试**：在单元测试中，可以使用 `context.TODO` 或 `context.Background` 来模拟上下文，确保测试代码的健壮性和隔离性。

### 用途

1. 并发控制
2. 错误传播
3. 提高代码可读性和可维护性
4. 标准化取消和超时逻辑

## 3.context是什么

## 4.context有什么作用

## 5.context.Value 的查找过程是怎样的

## context 如何被取消

# 06-channel

## 1.channel 是否线程安全；锁用在什么地方

1. Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据 都是 原子性的。
2. 而且Go的设计思想就是:不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。
3. 也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的

## 2.channel 的底层实现原理（数据结构）

channel是golang中用来实现多个goroutine通信的管道，它的底层是一个叫做hchan的结构体。在go的runtime包下。

数据结构

```go
type hchan struct {
  //channel分为无缓冲和有缓冲两种。
  //对于有缓冲的channel存储数据，借助的是如下循环数组的结构
	qcount   uint           // 循环数组中的元素数量
	dataqsiz uint           // 循环数组的长度
	buf      unsafe.Pointer // 指向底层循环数组的指针
	elemsize uint16 //能够收发元素的大小
  

	closed   uint32   //channel是否关闭的标志
	elemtype *_type //channel中的元素类型
  
  //有缓冲channel内的缓冲数组会被作为一个“环型”来使用。
  //当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置
	sendx    uint   // 下一次发送数据的下标位置
	recvx    uint   // 下一次读取数据的下标位置
  
  //当循环数组中没有数据时，收到了接收请求，那么接收数据的变量地址将会写入读等待队列
  //当循环数组中数据已满时，收到了发送请求，那么发送数据的变量地址将写入写等待队列
	recvq    waitq  // 读等待队列
	sendq    waitq  // 写等待队列


	lock mutex //互斥锁，保证读写channel时不存在并发竞争问题
}
```

对应图解：

![img](E:/Typora%20picture/a20f10cd62284684963a3a1edd44a90etplv-k3u1fbpfcp-jj-mark3024000q75.webp)

总结hchan结构体的主要组成部分有四个：

```
- 用来保存goroutine之间传递数据的循环链表。=====> buf。
- 用来记录此循环链表当前发送或接收数据的下标值。=====> sendx和recvx。
- 用于保存向该chan发送和从改chan接收数据的goroutine的队列。=====> sendq 和 recvq
- 保证channel写入和读取数据时线程安全的锁。 =====> lock
```



## 3.nil和关闭的channel、有数据的channel，再进行读、写、关闭 channel 会怎样

向nil 的channel 的读写都会阻塞；关闭nil的channel会报painc；

- 给一个 nil channel 发送数据，造成永远阻塞
- 从一个 nil channel 接收数据，造成永远阻塞
- 给一个已经关闭的 channel 发送数据，引起 panic
- 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值
- 无缓冲的channel是同步的，而有缓冲的channel是非同步的

## 4.向channel发送数据和从channel读数据的流程是怎么样的

#### 发送流程：

向一个channel中写数据简单过程如下：

1. 如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；
2. 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；
3. 如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；

简单流程图如下：

![img](E:/Typora%20picture/1661788117541-f82a3d7e-8b22-46cd-9bd9-dde26f0d290c-172128408152721.png)

#### 接收流程：

从一个channel读数据简单过程如下：

1. 如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；
2. 如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；
3. 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；
4. 将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；

简单流程图如下：

![img](E:/Typora%20picture/1661788153163-c386fedf-84b2-42ed-9965-d5d80743650c-172128408152823.png)

#### 关闭channel

关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。

除此之外，panic出现的常见场景还有：

1. 关闭值为nil的channel
2. 关闭已经被关闭的channel
3. 向已经关闭的channel写数据

## 5.讲讲Go的chan底层数据结构和主要使用场景

channel 的数据结构包含 qccount 当前队列中剩余元素个数，dataqsiz 环形队列长度，即可以存放的元素个数，buf 环形队列指针，elemsize 每个元素的大小，closed 标识关闭状态，elemtype 元素类型，sendx 队列下表，指示元素写入时存放到队列中的位置，recv 队列下表，指示元素从队列的该位置读出。recvq 等待读消息的 goroutine 队列，sendq 等待写消息的 goroutine 队列，lock 互斥锁，chan 不允许并发读写。

**无缓冲和有缓冲区别：** 管道没有缓冲区，从管道读数据会阻塞，直到有协程向管道中写入数据。同样，向管道写入数据也会阻塞，直到有协程从管道读取数据。管道有缓冲区但缓冲区没有数据，从管道读取数据也会阻塞，直到协程写入数据，如果管道满了，写数据也会阻塞，直到协程从缓冲区读取数据。

**channel 的一些特点** 1）、读写值 nil 管道会永久阻塞 2）、关闭的管道读数据仍然可以读数据 3）、往关闭的管道写数据会 panic 4）、关闭为 nil 的管道 panic 5）、关闭已经关闭的管道 panic

**向 channel 写数据的流程：** 如果等待接收队列 recvq 不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从 recvq 取出 G,并把数据写入，最后把该 G 唤醒，结束发送过程； 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 如果缓冲区中没有空余位置，将待发送数据写入 G，将当前 G 加入 sendq，进入睡眠，等待被读 goroutine 唤醒；

**向 channel 读数据的流程：** 如果等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G，把 G 中数据读出，最后把 G 唤醒，结束读取过程； 如果等待发送队列 sendq 不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程； 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；将当前 goroutine 加入 recvq，进入睡眠，等待被写 goroutine 唤醒；

**使用场景：** 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步

## 6.有缓存和无缓存channel

无缓存channel适用于数据要求同步的场景，而有缓存channel适用于无数据同步的场景。可以根据实现项目需求选择。

## 7.如何防止向已关闭的channel发送数据

### 1.状态标记：

在发送数据之前，先检查一个标志变量，这个变量指示 channel 是否已经关闭。如果 channel 已经关闭，则不再尝试发送数据。

```
var closed bool
ch := make(chan int)

go func() {
    // 当需要关闭 channel 时
    close(ch)
    closed = true
}()

// 发送数据前检查状态
if !closed {
    ch <- 1
}
```

### 2.使用select语句

使用 `select` 语句来尝试发送数据，并通过默认 case 来处理 channel 可能已经被关闭的情况

```
ch := make(chan int)

select {
case ch <- 1:
    // 成功发送数据
default:
    // channel 已经关闭或满（对于有缓冲的 channel），不执行发送
}
```

如果你只关心 channel 是否关闭，可以使用一个未缓冲的 channel 或者一个缓冲大小为 1 的 channel，这样在 `default` case 中，你就能确定 channel 是因为关闭而不是满而导致发送失败。

### 3.使用sync.Once

`sync.Once` 可以确保某个函数只被调用一次，这可以用来确保 channel 只被关闭一次。然而，这并不直接帮助你防止向已关闭的 channel 发送数据，但结合状态标记使用，可以确保 channel 的关闭是线程安全的。

```
var once sync.Once
var closed bool

func closeChannel() {
    once.Do(func() {
        close(ch)
        closed = true
    })
}

// 在发送数据前调用 closeChannel 并检查 closed
closeChannel()
if !closed {
    ch <- 1
}
```

### 4.监控channel的关闭状态

创建一个额外的 channel 来通知主 goroutine channel 已经关闭。这样，你可以在尝试发送数据之前检查这个额外的 channel。

```
ch := make(chan int)
closedCh := make(chan struct{})

go func() {
    // 当需要关闭 channel 时
    close(ch)
    closedCh <- struct{}{}
}()

select {
case <-closedCh:
    // channel 已经关闭
default:
    // 尝试发送数据
    ch <- 1
}
```

## 8.什么是CSP

## 9.channel底层的数据结构是什么

## 10.向channel发送数据的过程是怎样的

## 11.从channel接收数据的过程是怎样的

## 12.从一个关闭的channel仍然能读出数据吗

## 13.操作channel的情况总结

## 14.如何优雅的关闭channel

## 15.channel发送和接收元素的本质是什么

## 16.channel在什么情况下会引起资源泄露

## 17.关于channel的happend-before有哪些

## channel有哪些应用



# 07-GMP

## 1.进程、线程、协程有什么区别

进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。

线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。

协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行

## 2.什么是GMP



## 3.调度器的设计策略

**复用线程**：避免频繁的创建、销毁线程，而是对线程的复用。

1）work stealing（工作量窃取）机制

当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。

2）hand off（移交）机制

当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。

**利用并行**：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。

**抢占**：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。

**全局G队列**：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。

## 4.抢占式调度是如何抢占的

**基于协作式抢占**

**基于信号量抢占**

就像操作系统要负责线程的调度一样，Go的runtime要负责goroutine的调度。现代操作系统调度线程都是抢占式的，我们不能依赖用户代码主动让出CPU，或者因为IO、锁等待而让出，这样会造成调度的不公平。基于经典的时间片算法，当线程的时间片用完之后，会被时钟中断给打断，调度器会将当前线程的执行上下文进行保存，然后恢复下一个线程的上下文，分配新的时间片令其开始执行。这种抢占对于线程本身是无感知的，系统底层支持，不需要开发人员特殊处理。

基于时间片的抢占式调度有个明显的优点，能够避免CPU资源持续被少数线程占用，从而使其他线程长时间处于饥饿状态。goroutine的调度器也用到了时间片算法，但是和操作系统的线程调度还是有些区别的，因为整个Go程序都是运行在用户态的，所以不能像操作系统那样利用时钟中断来打断运行中的goroutine。也得益于完全在用户态实现，goroutine的调度切换更加轻量。

## 5.调度器的生命周期

![img](E:/Typora%20picture/1671108479128-e538cce4-0911-4683-ba0a-8a7866e4e2c1-172128437086427.png)

特殊的M0和G0

#### M0

M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。

#### G0

G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。

我们来跟踪一段代码

```go
package main 
import "fmt" 
func main() {
    fmt.Println("Hello world") 
}
```

接下来我们来针对上面的代码对调度器里面的结构做一个分析。

也会经历如上图所示的过程：

1. runtime创建最初的线程m0和goroutine g0，并把2者关联。
2. 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。
3. 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。
4. 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。
5. G拥有栈，M根据G中的栈信息和调度信息设置运行环境
6. M运行G
7. G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。

调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。

## 6.goroutine和线程的区别

## 7.什么是Go Scheduler

## 8.goroutine调度时机有哪些

## 9.什么是M:N模型

## 10.什么是工作窃取

## 11.GPM是什么

## 12.描述scheduler的初始化过程

## 13.主goroutine如何创建

## 14.g0栈和用户栈如何切换

## 15.schedule 循环如何启动

## 16.goroutine如何退出

## 17.schedule循环如何运转

## 18.M如何找工作

## 19.sysmon后台监控线程做了什么

## 20.一个调度相关的陷阱

## 21.虚拟内存和GMP的关系



# 08-锁相关

## 1.除了mutex 以外还有哪些方式安全读写共享变量

- 将共享变量的读写放到一个 goroutine 中，其它 goroutine 通过channel 进行读写操作。
- 可以用个数为 1 的信号量（semaphore）实现互斥
- 通过 Mutex 锁实现

## 2.Go如何实现原子操作

Go 语言的标准库代码包 sync/atomic 提供了原子的读取（Load 为前缀的函数）或写入（Store 为前缀的函数）某个值（这里细节还要多去查查资料）。

1）、互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。

2）、原子操作是针对某个值的单个互斥操作。

## 3.Mutex 是悲观锁还是乐观锁悲观锁和乐观锁是什么

**悲观锁**

悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。

**乐观锁**

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量

`sync.Mutex`在Go语言中实现的是悲观锁（Pessimistic Locking）。

## 4.Mutex 有几种模式

**1）正常模式**

1. 当前的mutex只有一个goruntine来获取，那么没有竞争，直接返回。
2. 新的goruntine进来，如果当前mutex已经被获取了，则该goruntine进入一个先入先出的waiter队列，在mutex被释放后，waiter按照先进先出的方式获取锁。该goruntine会处于自旋状态(不挂起，继续占有cpu)。
3. 新的goruntine进来，mutex处于空闲状态，将参与竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。

**2）饥饿模式**

在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin（自旋），它会乖乖地加入到等待队列的尾部。 如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:

1. 此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；
2. 此 waiter 的等待时间小于 1 毫秒。

## 5.goroutine 的自旋占用资源如何解决

自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。

**自旋的条件如下：**

1）还没自旋超过 4 次,

2）多核处理器，

3）GOMAXPROCS > 1，

4）p 上本地 goroutine 队列为空。

mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。

# 09-并发安全

## 1.讲讲Go中主协程如何等待其他协程退出

Go 的 sync.WaitGroup 是等待一组协程结束，sync.WaitGroup 只有 3 个方法，Add()是添加计数，Done()减去一个计数，Wait()阻塞直到所有的任务完成。Go 里面还能通过有缓冲的 channel 实现其阻塞等待一组协程结束，这个不能保证一组 goroutine 按照顺序执行，可以并发执行协程。Go 里面能通过无缓冲的 channel 实现其阻塞等待一组协程结束，这个能保证一组 goroutine 按照顺序执行，但是不能并发执行。

## 2.怎么控制并发数

**第一，有缓冲通道**

根据通道中没有数据时读取操作陷入阻塞和通道已满时继续写入操作陷入阻塞的特性，正好实现控制并发数量。

```go
func main() {
    count := 10                     // 最大支持并发
    sum := 100                      // 任务总数
    wg := sync.WaitGroup{}          //控制主协程等待所有子协程执行完之后再退出。
    c := make(chan struct{}, count) // 控制任务并发的chan
    defer close(c)
    for i := 0; i < sum; i++ {
        wg.Add(1)
        c <- struct{}{} // 作用类似于waitgroup.Add(1)
        go func(j int) {
            defer wg.Done()
            fmt.Println(j)
            <-c // 执行完毕，释放资源
        }(i)
    }
    wg.Wait()
}
```

**第二，三方库实现的协程池**

```go
import (
    "github.com/Jeffail/tunny"
    "log"
    "time"
)
func main() {
    pool := tunny.NewFunc(10, func(i interface{}) interface{} {
        log.Println(i)
        time.Sleep(time.Second)
        return nil
    })
    defer pool.Close()
    for i := 0; i < 500; i++ {
        go pool.Process(i)
    }
    time.Sleep(time.Second * 4)
}
```

## 3.多个goroutine 对同一个map写会panic异常是否可以用defer 捕获

可以捕获异常，但是只能捕获一次，Go语言，可以使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：defer, panic, recover Go中，对异常处理的原则是：多用error包，少用panic

```go
defer func() {
    if err := recover(); err != nil {
        // 打印异常，关闭资源，退出此函数
        fmt.Println(err)
    }
}()
```

## 4.如何优雅的实现一个goroutine池

* ants 源码阅读

## 5.golang实现多并发请求；发送多个get请求

在[go语言](https://so.csdn.net/so/search?q=go语言&spm=1001.2101.3001.7020)中其实有两种方法进行协程之间的通信。**一个是共享内存、一个是消息传递**

[**共享内存（互斥锁）**](https://blog.csdn.net/m0_43432638/article/details/108359182)

```go
//基本的GET请求
package main
 
import (
    "fmt"
    "io/ioutil"
    "net/http"
	"time"
	"sync"
	"runtime"
)
 
// 计数器
var counter int = 0
 
func httpget(lock *sync.Mutex){
	lock.Lock()
	counter++
    resp, err := http.Get("http://localhost:8000/rest/api/user")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    fmt.Println(string(body))
    fmt.Println(resp.StatusCode)
    if resp.StatusCode == 200 {
        fmt.Println("ok")
    }
	lock.Unlock()
}
 
func main() {
    start := time.Now()
	lock := &sync.Mutex{}
    for i := 0; i < 800; i++ {
        go httpget(lock)
    }
    for  {
        lock.Lock()
		c := counter
		lock.Unlock()
		runtime.Gosched()
        if c >= 800 {
            break
        }
    }
    end := time.Now()
    consume := end.Sub(start).Seconds()
    fmt.Println("程序执行耗时(s)：", consume)
}
```

问题

我们可以看到共享内存的方式是可以做到并发，但是我们需要利用共享变量来进行[协程](https://so.csdn.net/so/search?q=协程&spm=1001.2101.3001.7020)的通信，也就需要使用互斥锁来确保数据安全性，导致代码啰嗦，复杂话，不易维护。我们后续使用go的[消息传递](https://blog.csdn.net/m0_43432638/article/details/108349384)方式避免这些问题。

[**消息传递（管道）**](https://blog.csdn.net/m0_43432638/article/details/108349384)

```go
//基本的GET请求
package main
 
import (
    "fmt"
    "io/ioutil"
    "net/http"
	"time"
)
// HTTP get请求
func httpget(ch chan int){
    resp, err := http.Get("http://localhost:8000/rest/api/user")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    fmt.Println(string(body))
    fmt.Println(resp.StatusCode)
    if resp.StatusCode == 200 {
        fmt.Println("ok")
    }
	ch <- 1
}
// 主方法
func main() {
    start := time.Now()
    // 注意设置缓冲区大小要和开启协程的个人相等
    chs := make([]chan int, 2000)
    for i := 0; i < 2000; i++ {
        chs[i] = make(chan int)
        go httpget(chs[i])
    }
    for _, ch := range chs {
        <- ch
    }
    end := time.Now()
    consume := end.Sub(start).Seconds()
    fmt.Println("程序执行耗时(s)：", consume)
}
```

**总结：**

我们通过[go语言](https://so.csdn.net/so/search?q=go语言&spm=1001.2101.3001.7020)的管道channel来实现并发请求，能够解决如何避免传统共享内存实现并发的很多问题而且效率会高于共享内存的方法。

## 6、go的竞争问题

在Go语言中，“竞争条件”（Race Condition）是指两个或多个goroutine同时访问共享资源（如变量、数据结构等），并且至少有一个goroutine对其进行写操作时，可能导致程序行为不确定或错误的情况。这种情况在多线程或并发编程中很常见，Go语言通过内置的工具和机制帮助开发者检测和预防竞争条件。

### 竞争条件的产生原因
1. **并发读写**：多个goroutine同时读写同一个变量。
2. **未同步的访问**：在没有适当的同步机制（如锁）保护下访问共享资源。
3. **依赖于顺序的逻辑**：代码逻辑依赖于多个操作的特定顺序，但在并发环境中，操作的顺序可能因调度而改变。

### Go语言中的竞争检测
Go语言提供了一个强大的竞争检测器，它可以在编译时启用，通过`race`标志运行程序来检测竞争条件。例如：
```bash
go build -race myprogram.go
./myprogram
```
或
```bash
go run -race myprogram.go
```
当竞争检测器发现潜在的竞争条件时，它会在运行时报告问题，指出哪些变量可能受到竞争条件的影响。

### 避免竞争条件的策略
1. **使用互斥锁（Mutex）**：使用`sync.Mutex`或`sync.RWMutex`来同步对共享资源的访问，确保同一时间只有一个goroutine可以写入或读取资源。
2. **原子操作**：对于简单的类型（如int、uint等），使用`sync/atomic`包中的原子操作函数，如`AtomicAddInt64`和`AtomicLoadInt64`，这些操作是线程安全的。
3. **Channel通信**：使用channel进行goroutine间的通信和数据传递，channel提供了内置的同步机制，可以避免直接操作共享数据。
4. **数据结构的线程安全版本**：使用线程安全的数据结构，如`sync.Map`，或者在自己的数据结构中实现必要的同步逻辑。
5. **不变量和契约**：设计程序时考虑数据的不变量和契约，确保在并发环境中数据的完整性和一致性。

# 10-GC

## 1.GC是怎么实现的

Go 语言的内存回收机制是基于垃圾回收（Garbage Collection, GC）的自动化内存管理系统。它采用了一种称为“标记-清除”（Mark and Sweep）的算法，同时还引入了一些现代的优化和并发技术，以减少垃圾回收对程序性能的影响。以下是 Go 垃圾回收机制的一些关键特点：

1. **标记（Marking）**：
   - 垃圾回收器会遍历所有活跃的根集（roots），如全局变量、CPU寄存器、栈上的局部变量，以及之前已知的活动对象。
   - 它会递归地标记所有从根集可达的对象，即那些仍然被程序中的活动代码引用的对象。

2. **清除（Sweeping）**：
   - 清除阶段涉及回收未被标记的对象所占用的内存空间，这些对象被认为是垃圾，因为没有任何路径可以从根集到达它们。
   - 清除操作会更新内存管理结构，使得未标记的对象可以被重新使用。

3. **并发执行**：
   - 自 Go 1.5 版本以来，垃圾回收器可以与应用程序的其他部分并发运行，减少了停止世界（Stop-the-world）的时间，即暂停所有应用程序线程进行垃圾回收的时间。
   - 这是通过使用“三色标记法”（Three-color marking）、写屏障（Write Barrier）和辅助 GC（Helper GC）线程来实现的，这些技术有助于减少垃圾回收的暂停时间。

4. **触发机制**：
   - 垃圾回收通常在堆内存的使用达到一定阈值时被触发，或者在一段固定时间内自动运行，以保持堆内存的使用在一个可接受的水平。
   - 通过调整环境变量或运行时参数，可以控制垃圾回收的触发频率和行为。

5. **写屏障**：
   - 在并发标记期间，写屏障用于检测对象之间的引用更改，以确保标记过程的准确性，即使在并发修改的情况下也是如此。

6. **辅助 GC 线程**：
   - 辅助 GC 线程帮助主 GC 线程完成工作，减少主应用程序线程的负担，从而提高整体性能。

通过这些机制，Go 的垃圾回收器能够在保持内存高效利用的同时，尽量减少对程序性能的影响。这使得 Go 程序员可以专注于业务逻辑，而不必担心底层的内存管理细节。

## 2.GC算法是怎么实现的

[Golang GC算法解读](https://blog.csdn.net/shudaqi2010/article/details/90025192)

## 3.GC中stw时机，各个阶段是如何解决的



## 4.GC的触发时机

Go语言的垃圾回收（Garbage Collection，GC）触发时间并不固定，而是依据一定的策略和算法来决定的。Go的GC机制旨在保持堆内存的使用率在一个合理的水平，同时尽可能减少对程序运行时性能的影响。以下是影响Go语言内存回收触发时间的主要因素：

1. **堆内存使用情况**：
   - Go的GC主要根据堆内存的使用量来决定是否启动。当堆内存的使用达到一个预设的阈值时，GC就会被触发。这个阈值是动态调整的，通常在每次GC之后，新的阈值会根据上一次GC的效果来计算，以维持堆内存使用在一个目标比率附近。

2. **时间间隔**：
   - 虽然Go的GC并不是严格意义上的定时触发，但存在一个软性的时间间隔。如果在一段时间内没有因为堆内存使用量达到阈值而触发GC，那么GC会在大约2分钟的时间间隔后自动运行一次。这被称为“老化”（aging）机制的一部分，确保即使在较低的内存压力下也能周期性地进行内存清理。

3. **手动触发**：
   - 开发者也可以通过调用`runtime.GC()`函数来手动触发垃圾回收。这在某些特定情况下可能是有用的，比如在测试中或者在程序的特定阶段需要清理不再使用的资源。

4. **并发性**：
   - Go的GC是并发的，意味着它可以与应用程序的其他部分同时运行，这有助于减少“停止世界”（Stop-the-world）的暂停时间。GC的并发性有助于在进行垃圾回收的同时保持应用程序的响应性。

5. **触发比例（Trigger Ratio）**：
   - Go使用一个称为触发比例的概念来决定何时进行垃圾回收。触发比例是一个动态调整的值，它决定了堆增长多少后应该触发垃圾回收。例如，如果触发比例是100%，那么当堆使用量翻倍时，GC就会被触发。

由于Go的GC策略是动态和自适应的，实际的触发时间会根据程序的实际运行状态和配置参数而变化。这使得Go的GC能够在不同的负载条件下保持良好的性能和资源管理。

# 11-内存相关

## 1.内存分配原理

## 2.垃圾回收原理

## 3.逃逸分析

能引起变量逃逸到堆上的**典型情况**：

- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片 b 的背后存储都逃逸掉，所以会在堆上分配。

## 4.Go语言的内存模型及堆的分配管理

## 5.谈谈内存泄露，什么情况下内存会泄露怎么定位排查内存泄漏问题

1. **未释放的引用**：
   - 如果一个对象被无意识地持有引用，即使它不再需要，GC也无法回收这块内存，因为它认为这个对象仍然被引用。
2. **循环引用**：
   - 尽管Go的GC能够处理简单的循环引用，但在复杂的引用图中，如果两个或多个对象相互引用，而这些对象又不再被外部引用时，GC可能不会立即回收它们。
3. **缓存和存储结构**：
   - 当使用缓存或数据结构存储数据时，如果没有适当的清理策略，旧的数据可能会长期占据内存空间。
4. **goroutine泄漏**：
   - goroutine如果创建后没有适当地终止或等待其完成，可以导致内存泄露。每个活跃的goroutine都占用了一定的栈空间。
5. **网络连接或文件句柄**：
   - 打开的网络连接或文件句柄如果没有被关闭，不仅会导致文件描述符耗尽，还可能占用内存。
6. **未关闭的通道**：
   - 未关闭的通道会阻止goroutine退出，从而导致内存占用。

### 如何定位和排查内存泄露

1. **使用pprof**：
   - Go标准库提供的`pprof`包可以生成各种性能分析报告，包括内存使用情况。通过`pprof`可以获取内存快照并分析哪些对象占用了最多的内存。
   - 在浏览器中访问`http://localhost:6060/debug/pprof/heap`来查看内存使用情况。
2. **运行时工具**：
   - 使用`runtime.SetFinalizer()`可以设置一个finalizer，当对象不再被引用时，这个函数会被调用。虽然不推荐过度使用，但在某些场景下，这可以作为防止内存泄露的手段。
3. **代码审查**：
   - 定期审查代码，确保所有的资源（如文件、网络连接、goroutines等）在不再需要时被适当地关闭或清理。
4. **使用第三方工具**：
   - 除了标准库的工具外，还可以使用第三方工具如`Delve`调试器，或专门的性能分析工具来辅助定位问题。
5. **测试**：
   - 编写单元测试和集成测试，确保在各种条件下资源都能被正确释放。
6. **监控和日志**：
   - 在生产环境中，使用监控系统记录和跟踪内存使用情况，及时发现异常增长的趋势。
7. **理解Go的GC机制**：
   - 深入了解Go的垃圾收集机制，包括它的工作原理、何时运行以及如何影响程序性能，有助于更好地预防内存泄露。

## 6.golang 的内存逃逸吗什么情况下会发生内存逃逸（必问）

1. **函数返回局部变量的引用** 如果一个函数返回了一个局部变量的引用（如指针或包含指针的结构体），那么这个变量就不能在函数返回后被销毁，因为它仍然被外部引用。这种情况下，变量将被分配在堆上，而不是栈上。
2. **闭包捕获外部变量** 当函数（闭包）捕获了外部作用域的变量，而这个闭包被保存并可能在其他地方调用时，外部变量的生命周期将与闭包一样长，这通常意味着它们需要在堆上分配。
3. **全局变量或跨函数引用** ： 如果一个变量被多个函数引用或保存在全局作用域中，那么它的生命周期将超出局部作用域，从而需要在堆上分配。
4. **对象太大**如果一个对象的大小超过了栈帧的大小限制，那么即使它没有被外部引用，也会在堆上分配，以避免频繁的栈操作。
5. **动态类型** 当使用反射或接口类型的变量时，编译器可能无法确定其具体的类型和大小，从而将其放在堆上以适应任何可能的类型。
6. **切片中的指针元素** 如果切片包含指向堆上对象的指针，那么这些指针所指向的对象将不会被回收，直到最后一个引用消失，导致内存逃逸。

- 尽量使用局部变量而非全局变量。
- 避免不必要的闭包捕获。
- 减少大对象的使用，或将大对象分解为更小的部分。
- 使用编译器的 `-m` 标志来查看逃逸分析的信息，帮助识别和优化潜在的逃逸情况。

## 7.请简述 Go 是如何分配内存的

## 8.Go内存分配器

[go内存分配器](https://zhuanlan.zhihu.com/p/410317967)

Go 语言的内存分配机制相当复杂且高效，它采用了多种策略和技术来处理不同大小的对象，并尽可能地减少垃圾收集的频率和开销。下面是 Go 语言内存分配的主要组成部分和流程：

### 内存分配层次

1. **栈内存 (Stack)**
   - 栈内存用于存放函数调用的局部变量和函数参数。
   - 栈内存的分配和回收是自动的，随着函数的调用和返回进行。
   - 栈内存的使用非常快，因为它是基于寄存器和CPU指令集的操作。

2. **堆内存 (Heap)**
   - 堆内存用于存放动态分配的对象，包括全局变量、长生命周期的对象和大对象。
   - 堆内存的分配和回收由 Go 运行时的垃圾回收器管理。
   - 堆内存被进一步划分为不同的大小类别，以便更高效地分配和回收不同大小的对象。

### 堆内存管理组件

- **mheap**: 管理整个堆空间，是所有动态内存分配的基础。
- **mcentral**: 每个大小类别都有一个 mcentral 实例，它管理着可用的 mspan。
- **mcache**: 线程本地缓存，每个 goroutine 有一个 mcache，用于快速分配和回收小对象，减少锁的竞争。

### 内存分配单元

- **mspan**: 是 Go 内存管理的基本单元，每个 mspan 包含一组连续的内存页，用于分配相同大小的对象。
- **页**: 操作系统分配给 Go 运行时的最小内存单位，通常是 4KB 或 8KB。

### 分配策略

- **Tiny 分配器**: 用于极小对象（通常小于 32 字节），可以将多个对象分配在同一内存块中，以减少内存碎片。
- **Thread-Local Allocation Buffer (TLAB)**: 每个 goroutine 都有自己的 TLAB，用于快速分配小对象，减少锁的竞争。
- **空闲链表**: 维护已释放的内存块，以便重复使用。

### 对象大小分类

- **小对象**：小于等于 32KB 的对象，会被分配在适当的 mspan 上。
- **大对象**：大于 32KB 的对象，直接从 mheap 分配。

### 内存分配流程

1. 编译器和逃逸分析器决定变量是否需要在堆上分配。
2. 根据对象的大小，选择合适的分配策略。
3. 小对象尝试从当前 goroutine 的 mcache 或 TLAB 分配。
4. 如果 mcache 或 TLAB 中没有足够的空间，则从 mcentral 请求一个新的 mspan。
5. 大对象直接从 mheap 分配。
6. 如果请求的内存大小超过剩余的 mspan 空间，运行时会尝试从操作系统获取更多的内存页。

### 总结

Go 的内存分配机制旨在平衡速度和内存效率，通过线程本地缓存和大小分类来减少锁的竞争和内存碎片，同时利用垃圾回收器自动管理堆上的内存，使得开发人员无需手动管理内存，专注于业务逻辑的编写。



## 9.Channel 分配在栈上还是堆上哪些对象分配在堆上，哪些对象分配在栈上

在 Go 语言中，变量的存储位置（栈或堆）主要取决于变量的作用域和生命周期。下面是一些基本原则以及 `channel` 的具体讨论：

### 栈上分配

- **局部变量**：如果一个变量只在一个函数的局部作用域内使用，那么它通常会分配在栈上。当函数退出时，这些变量会被自动释放。
- **函数参数**：函数的参数通常也分配在栈上，它们的生命周期仅限于函数执行期间。
- **小对象**：如果一个对象足够小（通常小于一定阈值），并且不需要跨作用域存在，那么它也可能分配在栈上。

### 堆上分配

- **全局变量**：由于它们在整个程序执行期间都存在，所以分配在堆上。
- **长生命周期的对象**：如果一个对象的生命周期超出了局部作用域，例如作为返回值或传递给其他函数的参数，那么它将分配在堆上。
- **大对象**：如果一个对象的大小超过了栈的限制，那么它将分配在堆上。
- **动态创建的对象**：例如通过 `new()` 或 `make()` 创建的对象，它们总是分配在堆上。
- **循环引用和复杂数据结构**：如果数据结构有复杂的引用模式，例如双向链表或树形结构，它们通常分配在堆上。

### 关于 Channel 的分配

`Channel` 在 Go 语言中是一种特殊的通信原语，用于在 goroutines 之间同步和交换数据。`Channel` 的具体分配位置取决于它的使用场景：

- **局部 channel**：如果一个 `channel` 只在一个函数内部使用，并且没有被返回或作为参数传递给其他函数，理论上它可以分配在栈上。然而，由于 `channel` 内部包含了一些状态信息（如缓冲区、发送者和接收者的队列等），这些状态信息需要在多个 goroutine 之间共享和持久化，因此即使是一个局部的 `channel`，实际上也会分配在堆上。

- **全局或长生命周期的 channel**：如果一个 `channel` 被声明为全局变量或在多个函数间共享，那么它肯定会在堆上分配，因为它的生命周期超出了单个函数的作用域。

总结来说，无论 `channel` 是否看起来像是局部变量，由于其需要支持跨 goroutine 的通信，因此所有的 `channel` 都会分配在堆上。这是因为 `channel` 的实现涉及到了一些底层的数据结构和锁，这些都需要持久化的存储，而且它们可能被多个 goroutine 同时访问，这要求它们具有全局可访问性和稳定性，而这只能通过堆内存来实现。

## 10.介绍一下大对象小对象，为什么小对象多了会造成 gc 压力

在 Go 语言的内存管理中，对象根据其大小被分类为“大对象”和“小对象”，这种分类对垃圾回收（GC）的性能有显著影响。

### 小对象 vs 大对象

1. **小对象**：
   - 一般定义为小于或等于某个阈值的对象，这个阈值在 Go 语言中默认是 32KB。不过，实际的分类标准可能会受到逃逸分析和当前内存使用状况的影响。
   - 小对象通常可以更快地分配和回收，因为它们可以利用线程本地缓存（mcache）和线程本地分配缓冲区（TLAB）进行快速分配，减少了锁的竞争。
   - 由于小对象的分配和回收频繁，它们是垃圾回收的主要目标，尤其是当程序创建和销毁大量小对象时。

2. **大对象**：
   - 大于上述阈值的对象被认为是大对象。
   - 大对象直接从堆中分配，不经过线程本地缓存，因为它们通常不会很快被回收。
   - 大对象的分配和回收可能更慢，因为它们可能涉及到更大的内存区域，并且可能需要更多的内存页。

### 小对象过多造成 GC 压力的原因

- **频繁的内存分配与回收**：小对象的生命周期往往较短，这意味着它们会被频繁地创建和销毁。这种频繁的活动增加了垃圾回收的负担，因为GC需要跟踪哪些对象不再被引用，并且需要回收它们占用的内存。

- **内存碎片**：虽然小对象本身占用的空间不大，但是大量的小对象可能导致堆内存中出现许多小的空闲块，这些块可能太小而无法再用于分配新的对象，从而形成内存碎片。这会降低内存的使用效率，迫使GC更加频繁地进行整理和回收。

- **暂停时间（Pause Time）**：GC的暂停时间是指在GC过程中，应用程序暂时停止执行的时间。如果小对象过多，GC的暂停时间可能会变长，因为需要更多的时间来扫描和回收这些对象。这对于需要低延迟的应用程序尤其不利。

- **GC压力**：小对象的频繁生成和销毁会导致GC更加频繁地启动，这不仅消耗CPU资源，还可能影响应用程序的响应时间和性能。

为了减轻小对象过多造成的GC压力，Go 的运行时会采取一些优化措施，比如使用 TLAB 和 mcache 来加速分配过程，以及使用专门的小对象分配策略。此外，开发者也可以通过减少小对象的创建，比如复用对象、使用池化技术等，来降低GC的负担。

## 11.垃圾回收的认识

## 12.垃圾回收机制的实现

## 13.垃圾回收的优化问题

## 14.历史及演进

## 15.总结

# 12-编译

## 1.逃逸分析是怎么进行的

## 2.GoRoot 和GoPath 有什么用

## 3.Go编译相关的命令详解

## 4.Go程序启动过程是怎样的



# 13-框架

## 1、Gin

## 1-1、Gin框架如何进行参数校验的？

Gin 是一个用 Go 语言编写的高性能 Web 框架，它提供了多种方式来进行 HTTP 请求参数的校验。在 Gin 中，最常用和推荐的方式是使用 `binding` 包来校验绑定到结构体的请求数据。`binding` 包通常与第三方库 `github.com/go-playground/validator/v10` 结合使用，该库提供了强大的验证规则和自定义验证功能。

以下是如何在 Gin 中进行参数校验的步骤：

### 步骤 1: 安装必要的包

首先，确保安装了 `github.com/go-playground/validator/v10` 这个包，可以使用以下命令进行安装：

```sh
go get github.com/go-playground/validator/v10
```

### 步骤 2: 定义结构体

创建一个结构体来接收和验证请求参数。使用 `validate` 标签来定义验证规则：

```go
type LoginRequest struct {
    Email    string `form:"email" binding:"required,email"`
    Password string `form:"password" binding:"required,min=8"`
}
```

这里，`LoginRequest` 结构体定义了两个字段：`Email` 和 `Password`。`binding` 标签中的 `required` 规则表示字段是必填的，`email` 规则确保 `Email` 字段是一个有效的电子邮件地址，`min=8` 则确保密码长度至少为 8 个字符。

### 步骤 3: 编写路由和处理器

在 Gin 中编写路由和处理器来接收和校验请求参数：

```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
)

// 定义 LoginRequest 结构体

// 定义处理器
func LoginHandler(c *gin.Context) {
	var loginReq LoginRequest
	if err := c.ShouldBind(&loginReq); err != nil {
		// 获取验证器的翻译器，这里使用默认的英文翻译器
		translate := validator.NewTranslator("en")
		// 将验证错误转换成易于理解的消息
		errs, _ := err.(validator.ValidationErrors).Translate(translate)
		c.JSON(http.StatusBadRequest, gin.H{"error": errs})
		return
	}
	// 参数校验通过后，继续处理逻辑...
	c.JSON(http.StatusOK, gin.H{"message": "Login successful"})
}

func main() {
	router := gin.Default()
	router.POST("/login", LoginHandler)
	router.Run(":8080")
}
```

在上面的代码中，`ShouldBind` 方法用于将请求体中的数据绑定到 `LoginRequest` 结构体。如果绑定或验证失败，`ShouldBind` 方法会返回一个错误，你可以捕获这个错误并返回适当的错误消息给客户端。

### 步骤 4: 运行和测试

运行你的 Gin 应用程序，并尝试发送 POST 请求到 `/login` 路径，看看参数校验是否按预期工作。

以上就是在 Gin 框架中进行参数校验的基本步骤。你可以根据需求调整结构体和验证规则，以及处理错误的逻辑。此外，`validator` 包还支持自定义验证函数和国际化错误消息等功能，可以根据具体需求进一步定制。

## 1-2、Gin框架的http方法如何实现的

Gin框架是一个用Go语言编写的高性能Web框架，它提供了一种简洁且直观的方式来构建RESTful API和Web应用程序。Gin框架的核心功能之一是路由和HTTP方法的绑定，这使得开发者能够轻松地处理不同的HTTP请求。

在Gin框架中，HTTP方法的实现是通过`gin.Engine`和`gin.RouterGroup`的实例方法来完成的。`gin.Engine`是Gin框架的入口点，而`gin.RouterGroup`则是处理路由分组的。以下是一些常见的HTTP方法及其在Gin中的实现方式：

### HTTP方法的实现

1. **GET** 方法
   使用`GET`方法绑定一个处理函数到一个URL路径，当收到HTTP GET请求时，这个函数将被执行。
   ```go
   router.GET("/users/:id", getUserHandler)
   ```

2. **POST** 方法
   绑定一个处理函数到一个URL路径，当收到HTTP POST请求时，这个函数将被执行。
   ```go
   router.POST("/users", createUserHandler)
   ```

3. **PUT** 方法
   绑定一个处理函数到一个URL路径，当收到HTTP PUT请求时，这个函数将被执行。
   ```go
   router.PUT("/users/:id", updateUserHandler)
   ```

4. **DELETE** 方法
   绑定一个处理函数到一个URL路径，当收到HTTP DELETE请求时，这个函数将被执行。
   ```go
   router.DELETE("/users/:id", deleteUserHandler)
   ```

5. **PATCH** 方法
   绑定一个处理函数到一个URL路径，当收到HTTP PATCH请求时，这个函数将被执行。
   ```go
   router.PATCH("/users/:id", patchUserHandler)
   ```

6. **HEAD** 方法
   绑定一个处理函数到一个URL路径，当收到HTTP HEAD请求时，这个函数将被执行。
   ```go
   router.HEAD("/users/:id", headUserHandler)
   ```

7. **OPTIONS** 方法
   绑定一个处理函数到一个URL路径，当收到HTTP OPTIONS请求时，这个函数将被执行。
   ```go
   router.OPTIONS("/users/:id", optionsUserHandler)
   ```

8. **ANY** 方法
   绑定一个处理函数到一个URL路径，这个函数将对所有HTTP方法做出响应。
   ```go
   router.Any("/users/:id", anyUserHandler)
   ```

### 路由分组
`gin.RouterGroup`允许你创建一组路由，它们共享相同的前缀和中间件。这使得路由的管理更加清晰和模块化。
```go
userGroup := router.Group("/users")
{
    userGroup.GET("/:id", getUserHandler)
    userGroup.POST("/", createUserHandler)
}
```

### 中间件
Gin框架支持中间件，这些中间件可以在处理请求之前和之后执行，这对于添加认证、日志记录、错误处理等功能非常有用。
```go
router.Use(gin.Logger(), gin.Recovery())
```

### 总结
Gin框架通过`gin.Engine`和`gin.RouterGroup`提供了灵活的路由和HTTP方法绑定机制。

## 1-3、Gin框架的tag有哪些

## 2.go-zero

## 2-1 Go-Zero 是什么？它的主要功能是什么？它与其他Go框架有什么不同？

**Go-Zero 是什么？**  
Go-Zero（或写作 go-zero）是一个由社区驱动的 Go 语言高性能、高可用性微服务框架，专注于简化分布式系统的开发流程。它的设计目标是提供一套开箱即用的工具链和最佳实践，帮助开发者快速构建稳定、高效的微服务应用。

---

**主要功能**  
1. **微服务核心组件**  
   - 内置 **API 网关**、**RPC 服务**（基于 gRPC）、定时任务、异步队列等功能，支持服务注册与发现、负载均衡、熔断限流等微服务治理能力。  
   - 提供 **ETCD** 作为默认服务发现组件，同时支持自定义扩展。

2. **高性能与高并发**  
   - 通过优化的 **I/O 多路复用**（如基于 epoll/kqueue）和精简的中间件设计，实现低延迟和高吞吐量。  
   - 独创的 **“自适应熔断”** 机制，动态调整服务保护策略。

3. **代码生成工具（goctl）**  
   - 通过定义 API 和 RPC 的声明式配置文件（`.api` 和 `.proto`），自动生成项目骨架、CRUD 代码、Swagger 文档等，显著减少重复劳动。  
   - 支持一键生成 Dockerfile 和 Kubernetes 部署文件，简化运维。

4. **数据层优化**  
   - 内置 **缓存管理**（Cache-Aside 模式）和 **分布式事务** 支持，提供与数据库（如 MySQL、MongoDB）无缝集成的 ORM 工具。

5. **可观测性**  
   - 集成链路追踪（如 Jaeger）、指标监控（Prometheus）和日志聚合，方便故障排查与性能分析。

---

**与其他 Go 框架的差异**  
1. **定位不同**  
   - **Gin/ Echo**：轻量级 HTTP 框架，聚焦路由和中间件，微服务需自行集成其他组件。  
   - **Go-Zero**：一站式微服务框架，内置服务治理、代码生成等企业级功能，适合复杂分布式系统。

2. **开发效率**  
   - **Beego/ Revel**：全栈框架，但代码生成和微服务支持较弱。  
   - **Go-Zero**：通过 `goctl` 工具链实现“协议即文档，文档即代码”，提升开发速度，降低维护成本。

3. **性能优化**  
   - 相比通用框架，Go-Zero 在 **网络 I/O**、**序列化**（如 JSON 编码）等关键路径深度优化，性能对标一线大厂标准（如字节跳动 Go 框架）。

4. **工程化实践**  
   - 提供从开发到部署的完整工具链（如 API 版本管理、灰度发布支持），强调“约定大于配置”，减少团队协作中的风格分歧。

---

**总结**  
Go-Zero 的核心竞争力在于 **“工程化+性能”双引擎驱动**。它不仅是框架，更是微服务开发的最佳实践集合，尤其适合中大型团队快速构建高可靠、易维护的分布式系统。其代码生成和内置治理能力，显著降低了微服务的开发门槛，同时保持了 Go 语言原生的高效特性。





## 3.Echo



## 4.GoFrame



## 5. Gorm

## 5-1 GORM 如何实现一对多和多对多关系的映射

对于一对多关系，可以使用GORM 的BelongsTo 和HasMany 方法实现映射。比如：

```
type User struct {
    ID        uint
    Name      string
    Addresses []Address
}

type Address struct {
    ID      uint
    UserID  uint
    Address string
}

// User 模型对应的表应该包含一个外键，指向 Address 表中的 UserID 字段
// 使用 BelongsTo 和 HasMany 方法进行关联
func (u *User) Addresses() []Address {
    var addresses []Address
    DB.Model(&u).Association("Addresses").Find(&addresses)
    return addresses
}

func (a *Address) User() User {
    var user User
    DB.Model(&a).Association("User").Find(&user)
    return user
}
```

对于多对多关系，可以使用GORM 的ManyToMany 方法实现映射。比如：

```
type User struct {
    ID       uint
    Name     string
    Articles []Article `gorm:"many2many:user_articles"`
}

type Article struct {
    ID      uint
    Title   string
    Content string
    Users   []User `gorm:"many2many:user_articles"`
}
// User 和 Article 之间的关系通过 user_articles 表进行映射
```

## 5-2. 在使用 GORM 进行数据库查询时，如何避免 N + 1 查询的问题

N+1 查询问题指的是在查询关联表时，如果使用了嵌套循环进行查询，就会产生大量的 SQL 查询。为了避免这个问题，可以使用 GORM 的 Preload 方法预先加载关联数据。比如：

```
// 查询 Users 以及它们的 Addresses
var users []User
DB.Preload("Addresses").Find(&users)
```

这个查询会一次性加载所有 User 和 Address 数据，避免了 N+1 查询问题。

## 5-3. 如何使用GORM 进行事务管理

GORM 的事务管理使用 Begin、Commit 和 Rollback 方法实现。比如：

```
tx := DB.Begin()
defer func() {
    if r := recover(); r != nil {
        tx.Rollback()
    }
}()

// 在事务中执行一系列操作
if err := tx.Create(&user).Error; err != nil {
    tx.Rollback()
    return err
}

if err := tx.Create(&address).Error; err != nil {
    tx.Rollback()
    return err
}

// 提交事务
tx.Commit()
```

## 5-4. GORM 的 Preload 方法和Joins方法有什么区别？在什么情况下使用哪种方法更好

Preload 方法是在查询时预加载关联数据，而 Joins 方法是通过 SQL JOIN 语句连接多个表查询数据。**Preload 方法适用于关联表较少、数据量不大的情况；而 Joins 方法适用于关联表较多、数据量较大的情况。**

## 6. Kratos



## 7.字节 CloudWeGo

## 8.HTTP Hertz

## 9.RPC Kitex



