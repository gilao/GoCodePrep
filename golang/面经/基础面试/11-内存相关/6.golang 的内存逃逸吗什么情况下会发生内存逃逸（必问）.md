## 6.golang 的内存逃逸吗什么情况下会发生内存逃逸（必问）

1. **函数返回局部变量的引用** 如果一个函数返回了一个局部变量的引用（如指针或包含指针的结构体），那么这个变量就不能在函数返回后被销毁，因为它仍然被外部引用。这种情况下，变量将被分配在堆上，而不是栈上。
2. **闭包捕获外部变量** 当函数（闭包）捕获了外部作用域的变量，而这个闭包被保存并可能在其他地方调用时，外部变量的生命周期将与闭包一样长，这通常意味着它们需要在堆上分配。
3. **全局变量或跨函数引用** ： 如果一个变量被多个函数引用或保存在全局作用域中，那么它的生命周期将超出局部作用域，从而需要在堆上分配。
4. **对象太大**如果一个对象的大小超过了栈帧的大小限制，那么即使它没有被外部引用，也会在堆上分配，以避免频繁的栈操作。
5. **动态类型** 当使用反射或接口类型的变量时，编译器可能无法确定其具体的类型和大小，从而将其放在堆上以适应任何可能的类型。
6. **切片中的指针元素** 如果切片包含指向堆上对象的指针，那么这些指针所指向的对象将不会被回收，直到最后一个引用消失，导致内存逃逸。

- 尽量使用局部变量而非全局变量。
- 避免不必要的闭包捕获。
- 减少大对象的使用，或将大对象分解为更小的部分。
- 使用编译器的 `-m` 标志来查看逃逸分析的信息，帮助识别和优化潜在的逃逸情况。

