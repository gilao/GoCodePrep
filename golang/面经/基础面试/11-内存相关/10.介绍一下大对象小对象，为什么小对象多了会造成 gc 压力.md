## 10.介绍一下大对象小对象，为什么小对象多了会造成 gc 压力

在 Go 语言的内存管理中，对象根据其大小被分类为“大对象”和“小对象”，这种分类对垃圾回收（GC）的性能有显著影响。

### 小对象 vs 大对象

1. **小对象**：
   - 一般定义为小于或等于某个阈值的对象，这个阈值在 Go 语言中默认是 32KB。不过，实际的分类标准可能会受到逃逸分析和当前内存使用状况的影响。
   - 小对象通常可以更快地分配和回收，因为它们可以利用线程本地缓存（mcache）和线程本地分配缓冲区（TLAB）进行快速分配，减少了锁的竞争。
   - 由于小对象的分配和回收频繁，它们是垃圾回收的主要目标，尤其是当程序创建和销毁大量小对象时。

2. **大对象**：
   - 大于上述阈值的对象被认为是大对象。
   - 大对象直接从堆中分配，不经过线程本地缓存，因为它们通常不会很快被回收。
   - 大对象的分配和回收可能更慢，因为它们可能涉及到更大的内存区域，并且可能需要更多的内存页。

### 小对象过多造成 GC 压力的原因

- **频繁的内存分配与回收**：小对象的生命周期往往较短，这意味着它们会被频繁地创建和销毁。这种频繁的活动增加了垃圾回收的负担，因为GC需要跟踪哪些对象不再被引用，并且需要回收它们占用的内存。

- **内存碎片**：虽然小对象本身占用的空间不大，但是大量的小对象可能导致堆内存中出现许多小的空闲块，这些块可能太小而无法再用于分配新的对象，从而形成内存碎片。这会降低内存的使用效率，迫使GC更加频繁地进行整理和回收。

- **暂停时间（Pause Time）**：GC的暂停时间是指在GC过程中，应用程序暂时停止执行的时间。如果小对象过多，GC的暂停时间可能会变长，因为需要更多的时间来扫描和回收这些对象。这对于需要低延迟的应用程序尤其不利。

- **GC压力**：小对象的频繁生成和销毁会导致GC更加频繁地启动，这不仅消耗CPU资源，还可能影响应用程序的响应时间和性能。

为了减轻小对象过多造成的GC压力，Go 的运行时会采取一些优化措施，比如使用 TLAB 和 mcache 来加速分配过程，以及使用专门的小对象分配策略。此外，开发者也可以通过减少小对象的创建，比如复用对象、使用池化技术等，来降低GC的负担。

