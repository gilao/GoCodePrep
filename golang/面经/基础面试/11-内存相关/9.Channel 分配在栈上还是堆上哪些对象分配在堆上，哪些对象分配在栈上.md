## 9.Channel 分配在栈上还是堆上哪些对象分配在堆上，哪些对象分配在栈上

在 Go 语言中，变量的存储位置（栈或堆）主要取决于变量的作用域和生命周期。下面是一些基本原则以及 `channel` 的具体讨论：

### 栈上分配

- **局部变量**：如果一个变量只在一个函数的局部作用域内使用，那么它通常会分配在栈上。当函数退出时，这些变量会被自动释放。
- **函数参数**：函数的参数通常也分配在栈上，它们的生命周期仅限于函数执行期间。
- **小对象**：如果一个对象足够小（通常小于一定阈值），并且不需要跨作用域存在，那么它也可能分配在栈上。

### 堆上分配

- **全局变量**：由于它们在整个程序执行期间都存在，所以分配在堆上。
- **长生命周期的对象**：如果一个对象的生命周期超出了局部作用域，例如作为返回值或传递给其他函数的参数，那么它将分配在堆上。
- **大对象**：如果一个对象的大小超过了栈的限制，那么它将分配在堆上。
- **动态创建的对象**：例如通过 `new()` 或 `make()` 创建的对象，它们总是分配在堆上。
- **循环引用和复杂数据结构**：如果数据结构有复杂的引用模式，例如双向链表或树形结构，它们通常分配在堆上。

### 关于 Channel 的分配

`Channel` 在 Go 语言中是一种特殊的通信原语，用于在 goroutines 之间同步和交换数据。`Channel` 的具体分配位置取决于它的使用场景：

- **局部 channel**：如果一个 `channel` 只在一个函数内部使用，并且没有被返回或作为参数传递给其他函数，理论上它可以分配在栈上。然而，由于 `channel` 内部包含了一些状态信息（如缓冲区、发送者和接收者的队列等），这些状态信息需要在多个 goroutine 之间共享和持久化，因此即使是一个局部的 `channel`，实际上也会分配在堆上。

- **全局或长生命周期的 channel**：如果一个 `channel` 被声明为全局变量或在多个函数间共享，那么它肯定会在堆上分配，因为它的生命周期超出了单个函数的作用域。

总结来说，无论 `channel` 是否看起来像是局部变量，由于其需要支持跨 goroutine 的通信，因此所有的 `channel` 都会分配在堆上。这是因为 `channel` 的实现涉及到了一些底层的数据结构和锁，这些都需要持久化的存储，而且它们可能被多个 goroutine 同时访问，这要求它们具有全局可访问性和稳定性，而这只能通过堆内存来实现。

