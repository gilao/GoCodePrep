# 00-Go与其他语言

## 0.什么是面向对象：

### 面向对象 OOP：

* 面向对象编程是一种基于对象概念的编程范式，它可以包含数据和代码：数据以字段的形式存在（通常称为属性），代码是程序的形式存在（通常称为方法）；
* 对象自己的程序可以访问并经常修改自己的数据字段。
* 对象经常被定义为类的一个实例。
* 对象利用属性和方法的私有/受保护/公共可见性，对象的内部状态受到保护，不受外界影响（被封装）。

面向对象的三个基本特性；

* 封装
* 继承
* 多态

## 1.Go语言和Java有什么区别

1、Go上不允许函数重载，必须具有方法和函数的唯一名称，而Java允许函数重载。

2、在速度方面，Go的速度要比Java快。

3、Java默认允许多态，而Go没有。

4、Go语言使用HTTP协议进行路由配置，而Java使用Akka.routing.ConsistentHashingRouter和Akka.routing.ScatterGatherFirstCompletedRouter进行路由配置。

5、Go代码可以自动扩展到多个核心，而Java并不总是具有足够的可扩展性。

6、Go语言的继承通过匿名组合完成，基类以Struct的方式定义，子类只需要把基类作为成员放在子类的定义中，支持多继承;而Java的继承通过extends关键字完成，不支持多继承。

## 2.Go是面向对象的语言吗

是的，也不是。原因是：

1. Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次。
2. Go 中的 "接口 "概念提供了一种不同的方法，我们认为这种方法易于使用，而且在某些方面更加通用。还有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类。
3. Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、"未装箱的 "整数。它们并不局限于结构（类）。
4. Go 由于缺乏类型层次，Go 中的 "对象 "比 C++ 或 Java 等语言更轻巧。

## 3.Go实现面向对象编程

### 封装

向对象中的 “封装” 指的是可以隐藏对象的内部属性和实现细节，仅对外提供公开接口调用，这样子用户就不需要关注你内部是怎么实现的。

**在 Go 语言中的属性访问权限，通过首字母大小写来控制：**

- 首字母大写，代表是公共的、可被外部访问的。
- 首字母小写，代表是私有的，不可以被外部访问。

Go 语言的例子如下：

```
type Animal struct {
	name string
}

func NewAnimal() *Animal {
 	return &Animal{}
}

func (p *Animal) SetName(name string) {
 	p.name = name
}

func (p *Animal) GetName() string {
 	return p.name
}
```

在上述例子中，我们声明了一个结构体 Animal，其属性 name 为小写。没法通过外部方法，在配套上存在 Setter 和 Getter 的方法，用于统一的访问和设置控制。

### 继承

![image](E:/Typora%20picture/image-17209316396541.png)

从实际的例子来看，就是动物是一个大父类，下面又能细分为 “食草动物”、“食肉动物”，这两者会包含 “动物” 这个父类的基本定义。

**在 Go 语言中，是没有类似** **extends** **关键字的这种继承的方式，在语言设计上采取的是组合的方式**：

```go
type Animal struct {
 	Name string
}

type Cat struct {
 	Animal
 	FeatureA string
}

type Dog struct {
 	Animal
 	FeatureB string
}
```

在上述例子中，我们声明了 Cat 和 Dog 结构体，其在内部匿名组合了 Animal 结构体。因此 Cat 和 Dog 的实例都可以调用 Animal 结构体的方法：

```go
func main() {
 	p := NewAnimal()
 	p.SetName("我是搬运工，去给煎鱼点赞~")

 	dog := Dog{Animal: *p}
 	fmt.Println(dog.GetName())
}
```

上述例子能够正常包含调用 Animal 的相关属性和方法，也能够拥有自己的独立属性和方法，在 Go 语言中达到了类似继承的效果。

### 多态

面向对象中的 “多态” 指的同一个行为具有多种不同表现形式或形态的能力，具体是指一个类实例（对象）的相同方法在不同情形有不同表现形式。

多态也使得不同内部结构的对象可以共享相同的外部接口，也就是都是一套外部模板，内部实际是什么，只要符合规格就可以。

**在Go语言中，多态是通过接口来实现的**

```gO
type AnimalSounder interface {
 	MakeDNA()
}

func MakeSomeDNA(animalSounder AnimalSounder) {		// 参数是AnimalSounder接口类型
 	animalSounder.MakeDNA()
}
```

在上述例子中，我们声明了一个接口类型 AnimalSounder，配套一个 MakeSomeDNA 方法，其接受 AnimalSounder 接口类型作为入参。

因此在 Go 语言中。只要配套的 Cat 和 Dog 的实例也实现了 MakeSomeDNA 方法，那么我们就可以认为他是 AnimalSounder 接口类型：

```go
type AnimalSounder interface {
 	MakeDNA()
}

func MakeSomeDNA(animalSounder AnimalSounder) {
 	animalSounder.MakeDNA()
}

func (c *Cat) MakeDNA() {
 	fmt.Println("煎鱼是煎鱼")
}

func (c *Dog) MakeDNA() {
 	fmt.Println("煎鱼其实不是煎鱼")
}

func main() {
 	MakeSomeDNA(&Cat{})
 	MakeSomeDNA(&Dog{})
}
```

当 Cat 和 Dog 的实例实现了 AnimalSounder 接口类型的约束后，就意味着满足了条件，他们在 Go 语言中就是一个东西。能够作为入参传入 MakeSomeDNA 方法中，再根据不同的实例实现多态行为。

------

在日常工作中，基本了解这些概念就可以了。若是面试，可以针对三大特性：“封装、继承、多态” 和 五大原则 “单一职责原则（SRP）、开放封闭原则（OCP）、里氏替换原则（LSP）、依赖倒置原则（DIP）、接口隔离原则（ISP）” 进行深入理解和说明。

## 4.Go 语言和python的区别

1、范例

Python是一种基于面向对象编程的多范式，命令式和函数式编程语言。它坚持这样一种观点，即如果一种语言在某些情境中表现出某种特定的方式，理想情况下它应该在所有情境中都有相似的作用。但是，它又不是纯粹的OOP语言，它不支持强封装，这是OOP的主要原则之一。

Go是一种基于并发编程范式的过程编程语言，它与C具有表面相似性。实际上，Go更像是C的更新版本。

2、类型化

Python是动态类型语言，而Go是一种静态类型语言，它实际上有助于在编译时捕获错误，这可以进一步减少生产后期的严重错误。

3、并发

Python没有提供内置的并发机制，而Go有内置的并发机制。

4、安全性

Python是一种强类型语言，它是经过编译的，因此增加了一层安全性。Go具有分配给每个变量的类型，因此，它提供了安全性。但是，如果发生任何错误，用户需要自己运行整个代码。

5、管理内存

Go允许程序员在很大程度上管理内存。而，Python中的内存管理完全自动化并由Python VM管理；它不允许程序员对内存管理负责。

6、库

与Go相比，Python提供的库数量要大得多。然而，Go仍然是新的，并且还没有取得很大进展。

7、语法

Python的语法使用缩进来指示代码块。Go的语法基于打开和关闭括号。

8、详细程度

为了获得相同的功能，Golang代码通常需要编写比Python代码更多的字符。

# 01-基础部分

## 0.为什么选择golang

**0、高性能-协程**
golang 源码级别支持协程，实现简单；对比进程和线程，协程占用资源少，能够简洁高效地处理高并发问题。

**1、学习曲线容易-代码极简**

Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。

Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。

**2、效率：快速的编译时间，开发效率和运行效率高**

开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。

C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。

**3、出身名门、血统纯正**

之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。

**4、自由高效：组合的思想、无侵入式的接口**

Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。

**5、强大的标准库-生态**

背靠谷歌，生态丰富，轻松 go get 获取各种高质量轮子。用户可以专注于业务逻辑，避免重复造轮子。

这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。Go 语言的 lib 库麻雀虽小五脏俱全。Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。

**6、部署方便：二进制文件，Copy部署**

部署简单，源码编译成执行文件后，可以直接运行，减少了对其它插件依赖。不像其它语言，执行文件依赖各种插件，各种库，研发机器运行正常，部署到生产环境，死活跑不起来 。

**7、简单的并发**

并行和异步编程几乎无痛点。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。

Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。

创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。

**8、稳定性**

Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。

**9、跨平台**
很多语言都支持跨平台，把这个优点单独拿出来，貌似没有什么值得称道的，但是结合上述优点，它的综合能力就非常强了。

## 1.make 和new 的区别

* new 用于创建任何类型的零值指针

* make 用于初始化 slice、map和channel类型；

**共同点：给变量分配内存**

**不同点：**

1. 作用变量类型不同：new 可以给任意类型分配内存；make 给 slice、map、channel分配内存；
2. 返回类型不同：new 返回指向新分配的零值内存的指针，make初始化并返回一个可以直接使用的 slice、map 和 channel类型的值，而不是指针；
3. **new 分配的空间被初始化为其对应类型的零值，make分配空间后，会对 slice、map 和 channel 进行初始化，使其处于立即使用的状态，包括创建适当的底层数据结构和设置初始配置；**

## 2.IO多路复用

## 3.for range 问题

1. 迭代顺序：数组、切片可以按照索引递增顺序迭代；map 不保证迭代顺序；
2. **复制元素vs 引用：**当你在 `for range` 循环中遍历切片或数组时，每次循环都会创建元素的一个副本。这意味着如果在循环内修改循环变量，不会影响原始切片或数组中的元素；对于映射和通道，`for range` 会返回键和值的副本。因此，如果在循环中修改这些值，不会影响映射中的原始值。
3. **并发问题**：如果在 `for range` 循环中启动新的 goroutine，循环变量在 goroutine 中可能是不可预测的。当循环结束时，循环变量的值可能会被重置，导致 goroutine 使用无效的值。为了避免这个问题，应该在每个 goroutine 中捕获循环变量的值。**当从一个通道读取时，`for range` 会阻塞直到通道关闭或者有可用的值。如果通道永远不会关闭且没有值发送，循环将永久阻塞。**
4. **映射迭代的终止条件**：映射的迭代器在映射被删除（`delete` 调用）时会停止，即使还有未迭代的元素。因此，在迭代映射时不要删除映射的元素。
5. **通道的关闭与检测：**当从通道读取时，如果通道被关闭且没有更多的值可以读取，`for range` 循环会终止。可以通过检查从通道读取的第二个返回值（布尔值）来确定是否是因为通道关闭而退出循环。

在 for a,b := range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不要直接把 a 或者 b 的地址传给协程。解决办法：在每次循环时，创建一个临时变量。

for range 问题在1.22版本后正式优化了该问题

## 4.defer，多个defer的执行顺序；defer在什么情况下会修改return 返回值

作用：延迟函数；释放资源；收尾工作；释放锁、关闭文件、关闭连接、捕获panic；

多个defer调用顺序：LIFO 后入先出

defer 会修改 有名返回值或函数返回指针；

## 5.uint类型溢出问题

超过最大存储值如uint8最大是255

var a uint8 =255

var b uint8 =1

a+b = 0总之类型溢出会出现难以意料的事

![image-20240714134112799](E:/Typora%20picture/image-20240714134112799.png)

## 6.rune类型

相当int32

golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8

==**byte 等同于int8，常用来处理ascii字符**==

==**rune 等同于int32,常用来处理unicode或utf-8字符**==

![image-20240714134201454](E:/Typora%20picture/image-20240714134201454.png)

## 7.解析tag是如何实现的

## 8.调用函数传入结构体时，应该传值还是指针

Golang 都是传值

Go 的函数参数传递都是值传递。

值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数

因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。

## 9.goroutine 什么情况下会阻塞

## 10.讲讲Select底层数据结构和一些特性（项目中是如何使用 select的）

go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测是否有读写事件是否 ready。

**select 的特性**

1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。

2）select 仅支持管道，而且是单协程操作。

3）每个 case 语句仅能处理一个管道，要么读要么写。

4）多个 case 语句的执行顺序是随机的。

5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。

## 11.讲讲 defer 底层数据结构和一些特性

每个 defer 语句都对应一个_defer 实例， 多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果

**defer 的规则总结**：

延迟函数的参数是 defer 语句出现的时候就已经确定了的。

延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。

延迟函数可能操作主函数的返回值。

申请资源后立即使用 defer 关闭资源是个好习惯。

## 12.单引号、双引号、反引号的区别

## 13.出现panic额场景

- 数组/切片越界
- 空指针调用。比如访问一个 nil 结构体指针的成员
- 过早关闭 HTTP 响应体
- 除以 0
- 向已经关闭的 channel 发送消息
- 重复关闭 channel
- 关闭未初始化的 channel
- 未初始化 map。注意访问 map 不存在的 key 不会 panic，而是返回 map 类型对应的零值，但是不能直接赋值
- 跨协程的 panic 处理
- sync 计数为负数。
- 类型断言不匹配。`var a interface{} = 1; fmt.Println(a.(string))` 会 panic，建议用 `s,ok := a.(string)`

## 14.go是否支持while循环，如何实现这种机制

## 15.go如何实现set

## 16.go如何实现java的继承机制

## 17.怎么去复用一个接口的方法

## 18.go里面的_

1. 忽略返回值

2. 用在变量 特别是接口断言

3. 用在import package

   引入包时，会先调用包中的初始化函数，这种使用方式仅让导入的包做初始化，而不使用包中其他功能

## 19.goroutine 创建的时候如果要传入一个参数进去需要注意的点

## 20.写go单元测试的规范

## 21.单步测试

https://www.jianshu.com/p/21ed30859d80

## 22.导入一个go的工程，有些依赖找不到，改怎么办

## 23.值拷贝、引用拷贝；深拷贝、浅拷贝；

map，slice，chan 是引用拷贝；引用拷贝 是 浅拷贝

其余的，都是 值拷贝；值拷贝 是 深拷贝

#### 深浅拷贝的本质区别：

是否真正获取对象实体，而不是引用

**深拷贝：**

拷贝的是数据本身，创造一个新的对象，并在内存中开辟一个新的内存地址，与原对象是完全独立的，不共享内存，修改新对象时不会影响原对象的值。释放内存时，也没有任何关联。

**值拷贝：**

接收的是  整个array的值拷贝，所以方法对array中元素的重新赋值不起作用。

**浅拷贝：**

拷贝的是数据地址，只复制指向的对象的指针，新旧对象的内存地址是一样的，修改一个另一个也会变。释放内存时，同时释放。

**引用拷贝：**

函数的引用拷贝与原始的引用指向同一个数组，所以对数组中元素的修改，是有效的

## 24.精通Golang项目依赖Go modules

## 25.多返回值怎么实现的

Go语言利用了函数调用栈来管理返回值。当一个函数声明了多个返回值时，Go运行时会在栈上为每个返回值分配空间。当函数执行完毕时，这些返回值会被放置在栈上的特定位置，然后被调用者捕获。

## 26.Go 语言中不同的类型如何比较是否相等

## 27.Go中init 函数的特征

init 函数的执行顺序遵顼以下几个规则：

1. **包级别的init函数：**
   * 在一个包中声明的所有init函数按照他们在源代码文件中出现的顺序执行；
   * 如果一个包中有多个源文件，那么先按照文件名的字典排序，然后在每个文件内部再按照iniit函数声明的顺序执行
2. **导入顺序：**
   - 包的`init`函数的执行顺序取决于它们被导入的顺序。即，如果包A导入了包B和C，那么B和C的`init`函数将在A的`init`函数之前执行，但是B和C之间的执行顺序取决于它们在A的`import`语句中的出现顺序。
3. **依赖关系**
   - 如果包B依赖于包C（即B导入了C），那么C的`init`函数会在B的`init`函数之前执行。
4. **main包的init函数**
   - 所有其他包的`init`函数在main包的`init`函数执行之前完成。这意味着main包的`init`函数是整个程序中最后执行的`init`函数。
5. **嵌套init函数**
   - 如果一个`init`函数内部调用了另一个`init`函数，那么被调用的`init`函数将立即执行，而不是等到所有同级的`init`函数执行完。

## 28.Go中 uintptr和 unsafe.Pointer 的区别

## 29.Go程序如何优雅退出进程

# 02-slice

## 1.数组和切片的区别

## 2.讲讲Go的slice底层数据结构和一些特性

## 3.golang中数组和slice作为参数的区别slice作为参数传递有什么问题

## 4.从数组中取一个相同大小的slice有成本吗&从切片中取一个相同大小的数组有成本吗



# 03-map

## 1.map使用注意的点，是否并发安全

## 2.map循环是有序的还是无序的

## 3.map 中删除一个key，它的内存会释放吗

## 4.怎么处理对map进行并发访问有没有其他方案区别是什么

## 5.nil map和空 map有何不同

## 6.map的数据结构是什么

## 7.map是怎么实现扩容

## 8.查找过程

## 9.插入过程

## 10.slices 能作为map类型的key吗



# 04-接口

## 1.Go语言与鸭子类型的关系

## 2.值接收者和指针接收者的区别

## 3.iface和eface的区别是什么

## 4.接口的动态类型和动态值

## 5.编译器自动检测类型是否实现接口

## 6.接口的构造过程是怎样的

## 7.类型转换和断言的区别

## 8.接口转换的原理

## 9.如何用interface实现多态

## 10.Go 接口与C++接口有何异同



# 05-context

## 1.context结构是什么样的

context包的主要结构体和接口包括：

* **Context 接口**：实现了四个方法：`Done() <- chan struct{}`；`Err() error`；`Deadline() (deadline time.Time, ok bool)`；`Value(key interface{}) interface{}`
* **BaseContext结构体**；通常是 `Background`、`TODO` 上下文类型
* **CancelFunc函数类型**：当被调用时会取消一个上下文。它是 `WithCancel`, `WithDeadline` 和 `WithTimeout` 函数返回的第二个值。
* **derivedCtx 结构体**：`derivedCtx` 是所有派生上下文的基类，它持有对父上下文的引用和一些额外的字段。派生上下文包括通过 `WithCancel`, `WithDeadline` 和 `WithTimeout` 创建的上下文。
* **timerCtx 结构体**：`timerCtx` 是用于带有截止时间的上下文的类型，它包含一个定时器，用于在到达截止时间时关闭 `Done` 通道。
* **cancelCtx 结构体**：`cancelCtx` 是用于带有取消功能的上下文的类型，它包含一个无缓冲的通道 `done` 和一个 `children` 字段，用于跟踪所有子上下文。当 `cancelCtx` 被取消时，它会关闭 `done` 通道，并通知所有子上下文。
* **valueCtx 结构体**：`valueCtx` 是用于携带值的上下文的类型，它包含一个键值对，用于在上下文中传递数据。
* **emptyCtx 结构体**：`emptyCtx` 是一个特殊的 `Context` 实现，用于 `Background` 和 `TODO` 上下文。它是最简单的 `Context` 实现，不包含任何额外的状态。

## 2.context使用场景和用途

### 使用场景：

1. 跨API边界和goroutine 通信：当一个 HTTP 请求进入 web 服务器，可以创建一个 `context` 并将其传递给处理该请求的所有 goroutines。这样，如果请求被取消或超时，所有相关 goroutines 都可以接收到这个信号并停止其工作。
2. 超时控制：  对于可能需要很长时间才能完成的 I/O 操作或远程调用，可以使用 `context.WithTimeout` 或 `context.WithDeadline` 来创建一个带有限定时间的 `context`。一旦超时，所有使用该 `context` 的 goroutines 都会被通知并停止等待。
3. 取消操作 ：使用 `context.WithCancel` 可以创建一个可取消的 `context`。这在需要能够响应外部信号（如用户取消操作）的场景中非常有用。
4. 传递请求范围的数据： `context` 允许在请求的生命周期内传递数据，而不必在函数签名中显式传递。这对于日志记录、身份验证信息或追踪 ID 等数据特别有用。
5. 资源管理： `context` 可以用于协调资源的释放。例如，当 `context` 被取消时，所有相关 goroutines 可以释放它们占用的资源。
6. **测试**：在单元测试中，可以使用 `context.TODO` 或 `context.Background` 来模拟上下文，确保测试代码的健壮性和隔离性。

### 用途

1. 并发控制
2. 错误传播
3. 提高代码可读性和可维护性
4. 标准化取消和超时逻辑

# 06-channel

## 1.channel 是否线程安全；锁用在什么地方

## 2.channel 的底层实现原理（数据结构）

## 3.nil和关闭的channel、有数据的channel，再进行读、写、关闭 channel 会怎样

## 4.向channel发送数据和从channel读数据的流程是怎么样的

## 5.讲讲Go的chan底层数据结构和主要使用场景

## 6.有缓存和无缓存channel



# 07-GMP

## 1.进程、线程、协程有什么区别

## 2.什么是GMP

## 3.调度器的设计策略

## 4.抢占式调度是如何抢占的

## 5.调度器的生命周期



# 08-锁相关

## 1.除了mutex 以外还有哪些方式安全读写共享变量

## 2.Go如何实现原子操作

## 3.Mutex 是悲观锁还是乐观锁悲观锁和乐观锁是什么

## 4.Mutex 有几种模式

## 5.goroutine 的自旋占用资源如何解决



# 09-并发安全

## 1.讲讲Go中主协程如何等待其他协程退出

## 2.怎么控制并发数

## 3.多个goroutine 对同一个map写会panic异常是否可以用defer 捕获

## 4.golang实现多并发请求；发送多个get请求



# 10-GC

## 1.GC是怎么实现的

## 2.GC算法是怎么实现的

## 3.GC中stw时机，各个阶段是如何解决的

## 4.GC的触发时机



# 11-内存相关

## 1.内存分配原理

## 2.垃圾回收原理

## 3.逃逸分析

## 4.Go语言的内存模型及堆的分配管理

## 5.谈谈内存泄露，什么情况下内存会泄露怎么定位排查内存泄漏问题

## 6.golang 的内存逃逸吗什么情况下会发生内存逃逸（必问）

## 7.请简述 Go 是如何分配内存的

## 8.Go内存分配器

[go内存分配器](https://zhuanlan.zhihu.com/p/410317967)

## 9.Channel 分配在栈上还是堆上哪些对象分配在堆上，哪些对象分配在栈上

## 10.介绍一下大对象小对象，为什么小对象多了会造成 gc 压力



# 12-编译

## 1.逃逸分析是怎么进行的

## 2.GoRoot 和GoPath 有什么用

## 3.Go编译相关的命令详解

## 4.Go程序启动过程是怎样的



# 13-框架

## 1.Gin

## 2.go-zero

## 3.字节 CloudWeGo

## 4.HTTP Hertz

## 5.RPC Kitex
