# HTTP

## 0. HTTP 请求的Header里所包含的部分详解

Header 称为消息头；里面包含General(基本信息)、Response Headers（响应头）、Request Headers（请求头）、Query String Parameters(请求参数)

### 一、General

1.Request URL：请求的url

2.Request Method：请求的方式   HTTP请求方式中8种请求方法

3.Status Code：响应码

4.Remote Address：远程地址，包括ip和端口

5.Referrer Policy：HTTP系列之Referer和Referrer policy简介

### 二、Response Headers

**1.Access-Control-Allow-Credentials**：跨域Ajax请求时是否带Cookie的设置；表示是否允许发送cookies。默认情况下，Cookies不包括在CORS请求中；设为true表示cookies可以包含在请求中一起发给服务器，如果不需要发送cookies给服务器，需删除字段。需要注意的是：除了设置Access-Control-Allow-Credential：true外，在ajax请求中也必须打开withCredentials

**2.Access-Control-Allow-Methods**：必要字段 ，表示服务器支持的所有跨域请求方法，只要浏览器使用的请求方法包含在内即可通过

**3.Access-Control-Allow-Origin**：必要字段 ，该站点可以被哪些网站进行跨域资源共享

**4.Access-Control-Expose-Headers**：必要字段 ，表明服务器支持的所有头信息字段，也是为了避免多次预检请求

**5.Access-Control-Allow-Max-Age** ：可选字段， 单位是s，用来指定本次预检的有效期，即在给定时间内允许该条缓存回应，不会发出一条预检请求。

**6.Cache-Control**：控制缓存的行为  浅谈http中的Cache-Control

**7.Connection：**“Connection:Keep-Alive”或 “Connection:close”，这里具体的含义是有关http 请求的是否保持长连接，即链接是否复用，每次请求是复用已建立好的请求，还是重新建立一个新的请求。

**8.Content-Length**：在Http 1.0及之前版本中，content-length字段可有可无；在http1.1及之后版本。如果是keep alive，则content-length和chunk必然是二选一。若是非keep alive，则和http1.0一样。content-length可有可无。

**9.Content-Encoding**：Accept-Encoding 和Content-Encoding是HTTP中用来对采用哪种编码格式传输正文进行协定的一对头部字段。
（Content-Encoding 中的 gzip 和 deflate：

gzip，一种由文件压缩程序「Gzip，GUN zip」产生的编码格式，描述于 RFC 1952。这种编码格式是一种具有 32 位 CRC 的 Lempel-Ziv 编码（LZ77）；
deflate，由定义于 RFC 1950 的「ZLIB」编码格式与 RFC 1951 中描述的「DEFLATE」压缩机制组合而成的产物；）
**10.Content-Type**：代表发送端发送的实体数据的数据类型
（post请求肯定要发送数据包;因此对数据包的Type有专门的限定:Content-Type只能是
application/x-www-form-urlencoded,
application/json
multipart/form-data
或 text/plain中的一种。）

**11.Keep-Alive**：在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。

### 三、Response Headers

**1.Accept**：浏览器端可以接受的媒体类型,
例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档,如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)。

通配符 * 代表任意类型
例如 Accept: / 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。

**2.Accept-Encoding**：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码），例如： Accept-Encoding: zh-CN,zh;q=0.8 

**3.Accept-Language**：浏览器申明自己接收的语言。
语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等，例如： Accept-Language: en-us 

**4.Connection**：Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

**5.Referer**：当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。

**6.User-Agent**：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。

**7.Cache-Control**：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。我们网页的缓存控制是由HTTP头中的“Cache-control”来实现的，常见值有private、no-cache、max-age、must-revalidate等，默认为private。这几种值的作用是根据重新查看某一页面时不同的方式来区分的。

**8.Cookie**：Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储在cookie里面，比如sessionid等。

**9.If-Modified-Since**：作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中，例如：Mon, 17 Aug 2015 12:03:33 GMT 。

**10.If-None-Match**：作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能，例如: If-None-Match: W/“3119-1437038474000” 。



## 1.HTTP 常见的状态码及其含义

- 101:  切换请求协议
- 200：**（请求成功）**。服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
- 301 ： (永久移动，**永久性重定向，会缓存**) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
- 302：(临时移动，**临时重定向，不会缓存**) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 400 ：客户端请求有语法错误，不能被服务器所理解。
- 403 ：服务器收到请求，但是拒绝提供服务，服务器禁止访问，权限有关。
- 404 ：(未找到) 服务器找不到请求的网页。
- 494:请求头太大
- 495:https证书错误
- 496:https 没有证书
- 497:http到https
- 498:取消
- 499:客户端关闭链接（服务器端处理的时间过长，客户端“不耐烦”了，断开了链接。）

- - 代理服务器认为客户端发起的请求过于危险，所以主动切断了
  - 代理服务器没有办法连接到其他服务，导致timeout

- 500： (服务器内部错误) 服务器遇到错误，无法完成请求。
- 502:  网关错误
- 504:  网关超时



状态码开头代表类型：

![img](E:/Typora%20picture/1663037508351-47b0ab2e-8176-4f19-9924-8ab3e85274e4-17210296107461.png)



## 2.HTTP常用的请求方式，区别和用途

![img](E:/Typora%20picture/1648344507767-80be78d6-9d14-456f-a37e-9a552364c379-17210296939484.png)

- PUT：上传文件，向服务器添加数据，可以看作增
- DELETE：删除文件
- POST：传输数据，向服务器提交数据，对服务器数据进行更新。
- GET：获取资源，查询服务器资源

### 1.Get请求和Post请求的区别

**使用上的区别：**

-  GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。 
-  GET方式提交的数据有长度限制，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。 
-  POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。 

**本质区别：**

GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。

幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。

**思路:** 这道题主要考察的知识点是 POST 和 GET 的区别，可以从**数据包、编码方式、请求参数、收藏为书签、历史记录、安全性**等几方面去回答哈。

![img](E:/Typora%20picture/1648344509564-6dd9f2fe-4b82-4bce-95f1-c32cfb8fbab1-17210297847007.png)

## 3.请简单说一下你了解的端口及对应的服务

![img](E:/Typora%20picture/1648344507765-ed4bf561-22ba-4fe7-a800-a8119453ee1c-172102983878910.png)

## 4.计算机网络体系架构

![img](E:/Typora%20picture/1648344507793-5f9c3745-ad90-47eb-9815-6319ebef6644-172102987036913.png)

### 1.OSI七层模型

- **第 7 层：应用层** - 提供应用程序的接口。**常见的协议有HTTP、FTP、SMTP、SNMP、DNS；**
- **第 6 层：表示层** - 处理数据的加密、解密和格式转换。
- **第 5 层：会话层** - 管理会话的建立、维护和终止。
- **第 4 层：传输层** - 提供端到端的数据传输服务，**如 TCP 和 UDP 协议**。
- **第 3 层：网络层** - 负责路由选择和寻址，**如 IP 协议。**
- **第 2 层：数据链路层** - 提供节点间的数据帧传输，如以太网协议。
- **第 1 层：物理层** - 定义了物理信号和连接标准。

![img](E:/Typora%20picture/1635822448133-aadaef56-166b-4415-98d7-f574b90ad228-172103007858616.png)

### 2.TCP/IP 四层模型

- 应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。
- 传输层: 对应 OSI 的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。
- 网际层：对应于 OSI 参考模型的网络层，主要解决主机到主机的通信问题。
- 网络接口层：与 OSI 参考模型的数据链路层、物理层对应。

### 3.五层体系架构

- 应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。
- 传输层：对应 OSI 参考模型的的传输层
- 网络层：对应 OSI 参考模型的的网络层
- 数据链路层：对应 OSI 参考模型的的数据链路层
- 物理层：对应 OSI 参考模型的的物理层。

## 5.如何理解HTTP协议是无状态的

HTTP的无状态，指协议对于事务处理没有记忆能力，不对通信状态进行保存，服务器无法判断用户身份。即打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。服务器不会去记住你是谁，所以是无状态协议。

可以通过一个生活中的例子，来更好理解并记住它：

**有状态场景：**

- 小红：今天吃啥子？
- 小明：罗非鱼~
- 小红：味道怎么样呀？
- 小明：还不错，好香。

**无状态的场景：**

- 小红：今天吃啥子？
- 小明：罗非鱼~
- 小红：味道怎么样呀？
- 小明：？啊？你说啥？什么鬼？什么味道怎么样？

**Http 加了 Cookie 的话**：

- 小红：今天吃啥子？
- 小明：罗非鱼~
- 小红：你今天吃的罗非鱼，味道怎么样呀？
- 小明：还不错，好香。



## 6.从浏览器地址栏输入URL到显示主页的过程

**思路:** 这道题主要考察的知识点是 HTTP 的请求过程，**DNS 解析，TCP 三次握手，四次挥手这几个要点**，我们都可以讲下。

1. **DNS 解析，查找域名对应的 IP 地址。**
2. **与服务器通过三次握手，建立 TCP 连接**
3. **向服务器发送 HTTP 请求**
4. **服务器处理请求，返回网页内容**
5. **浏览器解析并渲染页面**
6. **TCP 四次挥手，连接结束**

### 在浏览器中输入 www.baidu.com 后执行的全部过程

1.  域名解析（域名 [www.baidu.com ](http://www.baidu.com/)变为 ip 地址）。
    **浏览器搜索自己的DNS缓存**（维护一张域名与IP的对应表）；若没有，则搜索**操作系统的DNS缓存**（维护一张域名与IP的对应表）；若没有，则搜索操作系统的**hosts文件**（维护一张域名与IP的对应表）。
    若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即**本地 dns 服务器**（递归查询），**本地域名服务器查询自己的dns缓存**，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。 
2.  发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 **80** 端口发起 tcp 的连接。 
3.  建立 tcp 连接后发起 http 请求。 
4.  服务器响应 http 请求，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。 
5.  浏览器解析 html 代码，并请求 html 中的资源。 
6.  浏览器对页面进行渲染，并呈现给用户。 

## 7.HTTP 1.0,1.1,2.0的区别

**HTTP/1.0**默认是短连接，可以强制开启，HTTP/1.1 默认长连接，HTTP/2.0 采用**多路复用**就差不多啦。

**HTTP/1.0**

- 默认使用**短连接**，每次请求都需要建立 TCP 连接。服务完成立即断开，开销大；
- 错误状态响应码少；
- 不支持断点续传。它可以设置`Connection: keep-alive` 这个字段，强制开启长连接。

**HTTP/1.1**

- 默认长连接，即 TCP 连接默认不关闭，可以被多个请求复用。
- 分块传输编码，即服务端每产生一块数据，就发送一块，用” 流模式” 取代” 缓存模式”。
- 管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。

**HTTP/2.0**

- 二进制协议，1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制，实现方便，健壮性更好。
- 完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。
- 报头压缩：HTTP 协议不带有状态，每次请求都必须附上所有信息。Http/2.0 引入了头信息压缩机制，使用 gzip 或 compress 压缩后再发送，同时通信的双方各自缓存一份header fields表，避免了header的重复传输。
- 服务端推送：允许服务器未经请求，主动向客户端发送资源。

#### 7.1 长连接和短连接？

HTTP协议的长连接和短连接，实质上就是TCP协议的长连接和短连接。

HTTP/1.0默认使用短连接，即Client和Server每进行一次HTTP操作，就建立一次连接，任务结束就中断。

HTTP/1.1起默认使用长连接，网页打开后，Client和Server间传输数据的TCP连接不会关闭，之后再进行访问就直接用已建立的连接。



## 8.长链接的实现及心跳机制

#### 心跳机制

应用层协议大多都有HeartBeat机制，通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线。

并传输一些可能必要的数据。使用心跳包的典型协议是IM，比如QQ/MSN/飞信等协议。

在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：SO_KEEPALIVE。

系统**默认是设置的2小时**的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。

而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。

#### 为什么需要心跳机制？

因为网络的不可靠性, 有可能在 TCP 保持长连接的过程中, 由于某些突发情况, 例如网线被拔出, 突然掉电等,

会造成服务器和客户端的连接中断. 在这些突发情况下, 如果恰好服务器和客户端之间没有交互的话, 那么它们是不能在短时间内发现对方已经掉线的.

心跳机制即可解决此类问题。使用心跳来判断client是否还连接到server上。

#### TCP协议的KeepAlive机制

默认KeepAlive状态是不打开的。

需要将setsockopt将SOL_SOCKET.SO_KEEPALIVE设置为1才是打开KeepAlive状态，

并且可以设置三个参数：

**tcp_keepalive_time ，tcp_keepalive_probes ， tcp_keepalive_intvl**，

分别表示：连接闲置多久开始发keepalive的ack包、发几个ack包不回复才当对方已断线、两个ack包之间的间隔。

很多网络设备，尤其是NAT路由器，由于其硬件的限制（例如内存、CPU处理能力），无法保持其上的所有连接，因此在必要的时候，会在连接池中选择一些不活跃的连接踢掉。

典型做法是LRU，把最久没有数据的连接给T掉。

通过使用TCP的KeepAlive机制（修改那个time参数），可以让连接每隔一小段时间就产生一些ack包，以降低被踢掉的风险，当然，这样的代价是额外的网络和CPU负担。

#### 如何实现心跳机制？

两种方式实现心跳机制:

- 使用 TCP 协议层面的 keepalive 机制.
- 在应用层上实现自定义的心跳机制.

虽然在 TCP 协议层面上, 提供了 keepalive 保活机制, 但是使用它有几个缺点:

1. 它不是 TCP 的标准协议, 并且是默认关闭的.
2. TCP keepalive 机制依赖于操作系统的实现, 默认的 keepalive 心跳时间是 **两个小时**, 并且对 keepalive 的修改需要系统调用(或者修改系统配置), 灵活性不够.
3. TCP keepalive 与 TCP 协议绑定, 因此如果需要更换为 UDP 协议时, keepalive 机制就失效了.

使用 TCP 层面的 keepalive 机制比自定义的应用层心跳机制节省流量,

#### TCP协议的KeepAlive机制

默认KeepAlive状态是不打开的。

需要将setsockopt将SOL_SOCKET.SO_KEEPALIVE设置为1才是打开KeepAlive状态，

并且可以设置三个参数：

**tcp_keepalive_time ，tcp_keepalive_probes ， tcp_keepalive_intvl**，

分别表示：连接闲置多久开始发keepalive的ack包、发几个ack包不回复才当对方已断线、两个ack包之间的间隔。

很多网络设备，尤其是NAT路由器，由于其硬件的限制（例如内存、CPU处理能力），无法保持其上的所有连接，因此在必要的时候，会在连接池中选择一些不活跃的连接踢掉。

典型做法是LRU，把最久没有数据的连接给T掉。

通过使用TCP的KeepAlive机制（修改那个time参数），可以让连接每隔一小段时间就产生一些ack包，以降低被踢掉的风险，当然，这样的代价是额外的网络和CPU负担。

#### 如何实现心跳机制？

两种方式实现心跳机制:

- 使用 TCP 协议层面的 keepalive 机制.
- 在应用层上实现自定义的心跳机制.

虽然在 TCP 协议层面上, 提供了 keepalive 保活机制, 但是使用它有几个缺点:

1. 它不是 TCP 的标准协议, 并且是默认关闭的.
2. TCP keepalive 机制依赖于操作系统的实现, 默认的 keepalive 心跳时间是 **两个小时**, 并且对 keepalive 的修改需要系统调用(或者修改系统配置), 灵活性不够.
3. TCP keepalive 与 TCP 协议绑定, 因此如果需要更换为 UDP 协议时, keepalive 机制就失效了.

使用 TCP 层面的 keepalive 机制比自定义的应用层心跳机制节省流量,

## 9.在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？

这个问题记住`keep-alive`就好，也就是说，在 HTTP 中响应体的**Connection**字段指定为`keep-alive`即可

## 10.HTTP如何实现长连接；在什么时候会超时

HTTP 的长连接实质是指 TCP 的长连接。至于什么时候超时，我们记住这几个参数如**tcp_keepalive_time**、**tcp_keepalive_probes**就好啦

**什么是 HTTP 的长连接？**

1. HTTP 分为长连接和短连接，**本质上说的是 TCP 的长短连接**。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才具有真正的长连接和短连接这一说法哈。
2. TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求，这样就可以减少资源消耗，比如一次请求 HTML，如果是短连接的话，可能还需要请求后续的 JS/CSS。

**如何设置长连接？**

通过在头部（请求和响应头）设置**Connection**字段指定为`keep-alive`，HTTP/1.0 协议支持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。

**在什么时候会超时呢？**

- HTTP 一般会有 httpd 守护进程，里面可以设置**keep-alive timeout**，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间
- TCP 的**keep-alive**包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了**tcp_keepalive_time**，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了**tcp_keepalive_probes**，就会丢弃该连接。

```
1. tcp_keepalive_intvl = 15 2. tcp_keepalive_probes = 5 3. tcp_keepalive_time = 1800
```

## 11.HTTP与HTTPS的区别

HTTP（超文本传输协议）与HTTPS（HTTP Secure，即安全的HTTP）之间的主要区别在于安全性、数据加密、证书验证、默认端口、以及对搜索引擎优化的影响等方面。下面是详细的对比：

1. **加密**：
   - **HTTP**：数据在传输过程中是未加密的，这意味着数据容易被截获和读取。
   - **HTTPS**：使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对数据进行加密，确保数据在客户端和服务器之间传输时的安全性，防止数据被窃听或篡改。

2. **证书认证**：
   - **HTTP**：没有数字证书认证，不能验证服务器的身份。
   - **HTTPS**：服务器使用数字证书来证明自己的身份，这通常是由受信任的证书颁发机构（CA）签发的，帮助用户确定他们正在访问的网站是合法的。

3. **端口号**：
   - **HTTP**：默认使用端口80。
   - **HTTPS**：默认使用端口443。

4. **安全性**：
   - **HTTP**：不提供数据保护，数据容易受到中间人攻击。
   - **HTTPS**：通过加密提供数据保护，防止中间人攻击和数据泄露。

5. **可信性**：
   - **HTTP**：无法确认服务器的真实身份。
   - **HTTPS**：通过证书验证服务器的身份，增加用户对网站的信任度。

6. **搜索引擎优化（SEO）**：
   - **HTTP**：不作为搜索引擎排名的考虑因素。
   - **HTTPS**：Google和其他搜索引擎已经明确表示，HTTPS是一个积极的排名信号，意味着使用HTTPS的网站可能会有更好的搜索排名。

7. **用户体验**：
   - **HTTP**：用户可能担心安全问题，尤其是在提交敏感信息时。
   - **HTTPS**：用户可以看到浏览器地址栏中的安全指示（如绿色锁图标），这增加了用户对网站的信任，提供了更安全的浏览体验。

8. **性能**：
   - **HTTP**：数据传输直接进行，没有加密的额外开销。
   - **HTTPS**：加密和解密数据会带来一些额外的计算开销，但在现代硬件和网络条件下，这种影响通常可以忽略不计。

总的来说，HTTPS提供了显著的安全优势，特别是在处理敏感数据或需要保护用户隐私的情况下。尽管HTTPS在早期可能因为加密和证书成本而被视为较重的解决方案，但随着技术的进步和对网络安全重视程度的提升，HTTPS已经成为互联网的标准。

## 12.HTTPS流程是怎样的

- HTTPS = HTTP + SSL/TLS，也就是用 SSL/TLS 对数据进行加密和解密，Http 进行传输。
- SSL，即 Secure Sockets Layer（安全套接层协议），是网络通信提供安全及数据完整性的一种安全协议。
- TLS，即 Transport Layer Security(安全传输层协议)，它是 SSL3.0 的后续版本。

![img](E:/Typora%20picture/1648344509841-0dbfbde5-b112-4ad0-9e7e-22e533219d29-172103086127619.png)

**Https 工作流程**

1. 客户端发起 Https 请求，连接到服务器的 443 端口。
2. 服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。
3. 服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。
4. 客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。
5. 客户端将公钥加密后的密钥发送到服务器。
6. 服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。
7. 服务器将加密后的密文返回到客户端。
8. 客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。

#### 12.1 SSL安全套接字层协议作用？

作用是建立安全连接，能和多个应用层协议协和使用保证安全传输。

- 记录协议：接收消息并处理，然后将处理过的消息继续传递。包括加解密、解压缩、分段重组等。
- 握手协议：建立在三次握手之后，为建立安全连接提供参数并进行双方的真实性认证。
- 警告协议：规定可能出现的错误等级和应对方式。
- 密码规范改变协议：在握手结束前发送，通知对方在之后的消息中使用商量好的加密算法。

## 13.说说 HTTP 的状态码？301 和 302 的区别？

**粗略地分：**

1xx：临时响应/请求正在处理；

2xx：成功

3xx：重定向

4xx：请求错误

5xx：服务器错误。 

**常见的状态码有：**

200：成功。

302：临时重定向到指定网页。

304：not modified服务器允许访问资源，但请求未满足条件。

400：bad request，请求报文存在语法错误。

401：unauthorized未授权，要求身份验证。

403：forbidden禁止，服务器拒绝访问。

404：not found未找到，服务器找不到请求的网页。

405：方法禁用，Post当成Get。

502：服务器网关错误。

503：service unavailable，服务器超负荷或停机维护。

504：网关超时，nginx请求超时。

## 14.说说什么是数字签名？什么是数字证书

数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份。它的出现，是为了避免身份被篡改冒充的。比如 Https 的数字证书，就是为了避免公钥被中间人冒充篡改：![img](E:/Typora%20picture/1648344509790-f338cc55-34e6-4c56-96d4-fcb3b7851467-172103130186322.png)



**数字证书构成**

- 公钥和个人等信息，经过 Hash 摘要算法加密，形成消息摘要；将消息摘要拿到拥有公信力的认证中心（CA），用它的私钥对消息摘要加密，形成**数字签名**。
- 公钥和个人信息、数字签名共同构成**数字证书**。

## 15.对称加密与非对称加密有什么区别

对称加密：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES 等。



![img](E:/Typora%20picture/1648344511455-364fd733-e783-4cdb-b2a8-c9fb8ba4933e-172103134706125.png)

对称加密

非对称加密：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有 RSA。



![img](E:/Typora%20picture/1648344511491-7bcdd3d6-c19f-41ce-861c-70b6f4c6db06-172103134707527.png)

非对称加密

## 16.DNS解析过程

DNS 的解析过程如下图：

![img](E:/Typora%20picture/1648344511680-72cde8e6-237e-4c3b-bb58-6b526b3aad26-172103141610431.png)



DNS 解析查找过程

假设你要查询**www.baidu.com**的 IP 地址:

- 首先会查找浏览器的缓存, 看看是否能找到**www.baidu.com**对应的 IP 地址，找到就直接返回；否则进行下一步。
- 将请求发往给本地 DNS 服务器，如果查找到也直接返回，否则继续进行下一步；
- 本地 DNS 服务器向**根域名服务器**发送请求，根域名服务器返回负责`.com`的顶级域名服务器的 IP 地址的列表。
- 本地 DNS 服务器再向其中一个负责`.com`的顶级域名服务器发送一个请求，返回负责`.baidu`的权威域名服务器的 IP 地址列表。
- 本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，返回**www.baidu.com**所对应的 IP 地址。

## 17.什么是CSRF攻击，如何避免

## 18.聊聊五层计算机网络体系结构中，每一层对应的网络协议有哪些？

![img](E:/Typora%20picture/1648344511729-74537b4b-de23-4710-87a8-b975951ddb31-172103159986434.png)

## 19.说说 WebSocket 与 socket 的区别

- Socket 其实就是等于**IP 地址 + 端口 + 协议**。

具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。

- WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决**http 不支持持久化连接**的问题。
- Socket 一个是**网编编程的标准接口**，而 WebSocket 则是应用层通信协议。

## 20.什么是 DoS、DDoS、DRDoS 攻击？

- **DOS**: (Denial of Service), 翻译过来就是拒绝服务, 一切能引起 DOS 行为的攻击都被称为 DOS 攻击。最常见的 DoS 攻击就有**计算机网络宽带攻击**、**连通性攻击**。
- **DDoS**: (Distributed Denial of Service), 翻译过来是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。常见的 DDos 有**SYN Flood、Ping of Death、ACK Flood、UDP Flood**等。
- **DRDoS**: (Distributed Reflection Denial of Service)，中文是分布式反射拒绝服务，该方式靠的是发送大量带有被害者 IP 地址的数据包给攻击主机，然后攻击主机对 IP 地址源做出大量回应，从而形成拒绝服务攻击。

## 21.什么是XSS攻击

**思路:** XSS 攻击也是比较常见，XSS，叫**跨站脚本攻击（Cross-Site Scripting）**，因为会与层叠样式表 (Cascading Style Sheets, CSS) 的缩写混淆，因此有人将跨站脚本攻击缩写为 XSS。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览该页之时，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。XSS 攻击一般分三种类型：**存储型 、反射型 、DOM 型 XSS**

#### 21.1 XSS 是如何攻击的呢？

拿反射型举个例子吧，流程图如下：



![img](E:/Typora%20picture/1648344512594-37d2cda6-b1cd-49bc-9f96-1c971a5466bf-172103171740737.png)



#### 21.2 如何解决 XSS 攻击问题？

- 对输入进行过滤，过滤标签等，只允许合法值。
- HTML 转义
- 对于链接跳转，如`<a href="xxx"` 等，要校验内容，禁止以 script 开头的非法链接。
- 限制输入长度

## 22.HTTP请求过程与原理

HTTP 是一个基于 TCP/IP 协议来传递数据的超文本传输协议，传输的数据类型有 HTML, 图片等。以访问百度有例子，看下一次 Http 的请求过程吧

![img](E:/Typora%20picture/1648344512577-14499b9f-323e-4dbf-9864-ec24b46aea68-172103177300940.png)

HTTP 请求过程

1. 客户端进行 DNS 域名解析，得到对应的 IP 地址
2. 根据这个 IP，找到对应的服务器建立连接（三次握手）
3. 建立 TCP 连接后发起 HTTP 请求（一个完整的 http 请求报文）
4. 服务器响应 HTTP 请求，客户端得到 html 代码
5. 客户端解析 html 代码，用 html 代码中的资源 (如 js,css, 图片等等) 渲染页面。
6. 服务器关闭 TCP 连接（四次挥手）

## 23.forward和redirect的区别

- **直接转发方式（Forward）** ，客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。
- **间接转发方式（Redirect）** 实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。

- Redirect 的工作原理：

![img](E:/Typora%20picture/1648344512999-badb6a58-4403-4881-9107-bde49da48798.png)

- forward 的工作原理

![img](E:/Typora%20picture/1648344513019-b1e630c0-6891-4b31-9698-439609621927-172103188073544.png)

## 24.SQL注入

SQL 注入是一种代码注入技术，一般被应用于攻击 web 应用程序。它通过在 web 应用接口传入一些特殊参数字符，来欺骗应用服务器，执行恶意的 SQL 命令，以达到非法获取系统信息的目的。它目前是黑客对数据库进行攻击的最常用手段之一。

#### 24.1 SQL 注入是如何攻击的？

举个常见的**业务场景**：在 web 表单搜索框输入员工名字，然后后台查询出对应名字的员工。



![img](E:/Typora%20picture/1648344513240-53b0cfe7-31a1-408a-a8e9-0500b80e7b74-172103195107648.png)



这种场景下，一般都是前端页面, 把一个名字参数 name 传到后台，然后后台通过 SQL 把结果查询出来

```sql
name = "田螺"; // 前端传过来的

// 根据前端传过来的 name 参数，查询数据库员工表 staff
SQL= "select * from staff where name=" + name;  
```

因为 SQL 是直接拼接的，如果我们完全信任前端传的参数的话。假如前端传这么一个参数时`''or'1'='1'`，SQL 就变成酱紫的啦。



```
select * from staff where name=''or'1'='1';
```



这个 SQL 会把所有的员工信息全都查出来了，酱紫就请求用户已经越权啦。请求者可以获取所有员工的信息，信息已经暴露了啦。

#### 24.2 如何预防 SQL 注入问题

**1). 使用 #{} 而不是 ${}**

在 MyBatis 中, 使用`**#{}**`而不是`**${}**`，可以很大程度防止 sql 注入。

- 因为`**#{}**`是一个参数占位符，对于字符串类型，会自动加上 ""，其他类型不加。由于 Mybatis 采用**预编译**，其后的参数不会再进行 SQL 编译，所以一定程度上防止 SQL 注入。
- `**${}**`是一个简单的字符串替换，字符串是什么，就会解析成什么，存在 SQL 注入风险

**2). 不要暴露一些不必要的日志或者安全信息，比如避免直接响应一些 sql 异常信息。**

如果 SQL 发生异常了，不要把这些信息暴露响应给用户，可以自定义异常进行响应

**3). 不相信任何外部输入参数，过滤参数中含有的一些数据库关键词关键词**

可以加个参数校验过滤的方法，过滤`union，or`等数据库关键词

**4). 适当的权限控制**

在你查询信息时，先校验下当前用户是否有这个权限。比如说，实现代码的时候，可以让用户多传一个企业 Id 什么的，或者获取当前用户的 session 信息等，在查询前，先校验一下当前用户是否是这个企业下的等等，是的话才有这个查询员工的权限。



## 25.Session 和 Cookie 的区别

**我们先来看 Session 和 Cookie 的概念吧：**

- Cookie 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。服务器就是根据这个 Cookie 来确认身份的。
- session 指的就是服务器和客户端一次会话的过程。Session 利用 Cookie 进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个 Cookie，当这个 Session 结束时，其实就是意味着这个 Cookie 就过期了。Session 对象存储着特定用户会话所需的属性及配置信息。

**Session 和 Cookie 的区别主要有这些：**

![img](E:/Typora%20picture/1648344513597-40e479f8-f8f1-4d19-953e-58a67959ae45-172103198716951.png)

来看个图吧：

![img](E:/Typora%20picture/1648344513602-d581e6dd-773d-4485-aabc-ff4e75badc34-172103198717553.png)

- 用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。
- 当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

#### 25.1 如何保持会话状态

1. **Cookie和Session保存会话状态，用Session来唯一标识用户，用Cookie当作用户通行证**。

流程：

- - 服务端收到请求处理后生成一个SessionId，将SessionId存入Cookie返回给客户端，将Session内容存储在服务器上。
  - 下一次请求时，客户端带着Cookie来请求服务器，服务端从Cookie中取出SessionId，从而实现用户会话状态的保持。

1.  第一次登陆后，**服务端生成Token给客户端，客户端之后带着Token请求数据即可**。减轻服务器的压力，减少频繁查询数据库。

#### 25.2 不同会话状态的区别

- Cookie：在客户端保存用户信息，安全性较差，并且浏览器会限制cookie数量。例如： 保存登录用户信息，下次自动填写登录信息；登录网 站后访问其他页面就不用登录。
- Session：在服务端记录用户状态，安全性较高，但占用服务器性能。例如：购物车添加物品，根据Session知道用户的购物车。
- Token：在客户端保存认证授权状态，适合前后端分离的项目(处于不同服务器)。

## 26.IP地址有哪些分类

一般可以这么认为，IP 地址 = 网络号 + 主机号。

1. 网络号：它标志主机所连接的网络地址表示属于互联网的哪一个网络。
2. 主机号：它标志主机地址表示其属于该网络中的哪一台主机。

IP 地址分为 A，B，C，D，E 五大类：

- A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位。
- B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位。
- C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位。
- D 类地址 (224~239)：以 1110 开头，保留位多播地址。
- E 类地址 (240~255)：以 11110 开头，保留位为将来使用

![img](E:/Typora%20picture/1648344514317-00a3581b-e3bf-4449-a5e2-483f23853ece-172103205885357.png)

### 27. 说下 ARP 协议的工作过程？

ARP 协议协议，**Address Resolution Protocol**，地址解析协议，它是用于实现 IP 地址到 MAC 地址的映射。

1. 首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。
2. 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的 ARP 列表，是否存在该 IP 地址对应的 MAC 地址；如果有﹐就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求的数据包里，包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。
3. 网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。
4. 源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。

### 28. 有了 IP 地址，为什么还要用 MAC 地址？

- 简而言之，标识网络中的一台计算机，比较常用的就是**IP 地址和 MAC 地址**，但计算机的 IP 地址可由用户自行更改，管理起来就相对困难，而 MAC 地址不可更改，所以一般会把 IP 地址和 MAC 地址组合起来使用。
- 那只使用 MAC 地址不用 IP 地址行不行呢？不行的！因为最早就是 MAC 地址先出现的，并且当时并不用 IP 地址，只用 MAC 地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可。
- 那为什么要用 IP 地址呢？是因为 IP 地址是和地域相关的，对于同一个子网上的设备，IP 地址的前缀都是一样的，这样路由器通过 IP 地址的前缀就知道设备在在哪个子网上了，而只用 MAC 地址的话，路由器则需要记住每个 MAC 地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。
- IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。

# TCP

## 1.  TCP 和 UDP 分别对应的常见应用层协议有哪些？

**基于 TCP 的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH**

- **HTTP**：HyperText Transfer Protocol（超文本传输协议），默认端口 80
- **FTP**: File Transfer Protocol (文件传输协议), 默认端口 (20 用于传输数据，21 用于传输控制信息)
- **SMTP**: Simple Mail Transfer Protocol (简单邮件传输协议) , 默认端口 25
- **TELNET**: Teletype over the Network (网络电传), 默认端口 23
- **SSH**：Secure Shell（安全外壳协议），默认端口 22

**基于 UDP 的应用层协议：DNS、TFTP、SNMP**

- **DNS** : Domain Name Service (域名服务), 默认端口 53
- **TFTP**: Trivial File Transfer Protocol (简单文件传输协议)，默认端口 69
- **SNMP**：Simple Network Management Protocol（简单网络管理协议），通过 UDP 端口 161 接收，只有 Trap 信息采用 UDP 端口 162。

## 2.聊聊保活计时器的作用（客户端连接成功之后发生故障怎么处理）

除时间等待计时器外，TCP 还一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。

服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若**连续发送 10 个探测报文段**后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。

### 3.如果服务器出现了大量 CLOSE_WAIT 状态如何解决。

![img](E:/Typora%20picture/1648344514375-b3395634-6b7f-46a0-bef5-03e911033c1a-172103215962460.png)

- 服务器端收到客户端发送的`FIN`后，TCP 协议栈就会自动发送 ACK，接着进入**CLOSE_WAIT**状态。
- 但是如果服务器端不执行 socket 的 close() 操作，那么就没法进入 LAST_ACK, 导致大量连接处于 CLOSE_WAIT 状态
- 所以，如果服务器出现了大量**CLOSE_WAIT**状态，一般是程序 Bug，或者关闭 socket 不及时。

## 3.URI 和 URL 的区别

- URI，全称是 Uniform Resource Identifier)，中文翻译是统一资源标志符，主要作用是唯一标识一个资源。
- URL，全称是 Uniform Resource Location)，中文翻译是统一资源定位符，主要作用是提供资源的路径。打个经典比喻吧，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人。

## 4.ICMP 协议的功能

ICMP,Internet Control Message Protocol ,Internet 控制消息协议。

- ICMP 协议是一种面向无连接的协议，用于传输出错报告控制信息。
- 它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括**报告错误、交换受限控制和状态信息**等。
- 当遇到 IP 数据无法访问目标、IP 路由器无法按当前的传输速率转发数据包等情况时，会自动发送 ICMP 消息。

比如我们日常使用得比较多的**ping**，就是基于 ICMP 的。

## 5.说下 ping 的原理

ping，**Packet Internet Groper**，是一种因特网包探索器，用于测试网络连接量的程序。Ping 是工作在 TCP/IP 网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态

一般来说，ping 可以用来检测网络通不通。它是基于`ICMP`协议工作的。假设**机器 A** ping**机器 B**，工作过程如下：

1. ping 通知系统，新建一个固定格式的 ICMP 请求数据包
2. ICMP 协议，将该数据包和目标机器 B 的 IP 地址打包，一起转交给 IP 协议层
3. IP 层协议将本机 IP 地址为源地址，机器 B 的 IP 地址为目标地址，加上一些其他的控制信息，构建一个 IP 数据包
4. 先获取目标机器 B 的 MAC 地址。
5. 数据链路层构建一个数据帧，目的地址是 IP 层传过来的**MAC 地址**，源地址是本机的**MAC 地址**
6. 机器 B 收到后，对比目标地址，和自己本机的 MAC 地址是否一致，符合就处理返回，不符合就丢弃。
7. 根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间
8. 最终显示结果有这几项：发送到目的主机的 IP 地址、发送 & 收到 & 丢失的分组数、往返时间的最小、最大 & 平均值

**总结**：ping的工作过程

1. 向目的主机发送多个ICMP回送请求报文
2. 根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。

## 6.TCP 的三次握手机制

TCP提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的就是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。我们一起来看下流程图哈

![img](E:/Typora%20picture/1635823290481-2a91819b-20e2-44ca-a728-3371d9a7b2d5-172103223750863.png)

**流程：**

- 第一次握手 (发送连接请求报文SYN=1, 初始序号随机seq=x，ACK=0)，发送完毕后，客户端就进入 SYN_SENT 状态
- 第二次握手 (发送连接确认报文SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端就进入 SYN_RCV 状态。
- 第三次握手 (发出连接确认报文ACK=1，ACKnum=y+1，序号seq=x+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态。

ACK也好，ack也好，只不过是个代号而已
ACK是确认值(Acknowledgement)，为1便是确认连接。
ack是确认编号(Acknowledgement Number)，即接收到的上一次远端主机传来的seq然后+1，再发送给远端主机。提示远端主机已经成功接收上一次所有数据。

## 7.TCP和HTTP的关系

TCP（Transmission Control Protocol，传输控制协议）和HTTP（Hypertext Transfer Protocol，超文本传输协议）是网络通信中不同层次的协议，它们之间有着紧密的关联，但各自扮演着不同的角色。

### TCP
TCP位于OSI模型的传输层（第四层），负责在不可靠的网络上提供可靠的、面向连接的数据传输服务。TCP的主要职责包括：
- 建立连接：通过三次握手过程建立可靠的连接。
- 数据传输：将数据分割成数据段，进行有序传输，提供错误检测和恢复，确保数据按序到达。
- 流量控制：防止接收方被大量数据淹没。
- 拥塞控制：防止网络拥塞。
- 关闭连接：通过四次挥手过程关闭连接。

### HTTP
HTTP位于OSI模型的应用层（第七层），它定义了客户端和服务器之间如何交换数据的规则，主要用于万维网（WWW）上的数据通信。HTTP的主要职责包括：
- 请求/响应模型：客户端发送请求，服务器响应请求。
- 无状态性：每个请求都是独立的，服务器不保存客户端状态。
- 支持多种方法：GET, POST, PUT, DELETE等。
- 支持多种内容类型：文本、图片、视频等。

### TCP和HTTP的关系
HTTP使用TCP作为其传输层协议，这意味着HTTP请求和响应都是通过TCP连接发送的。具体来说：
- HTTP请求和响应通过TCP连接传输，利用TCP提供的可靠性和流控制。
- 每个HTTP事务（请求和响应）通常在一个TCP连接中完成，但在持久连接（Keep-Alive）中，多个事务可以在同一个TCP连接中进行。
- HTTPS，即安全的HTTP，使用TLS/SSL协议在TCP之上提供了加密层，增加了数据传输的安全性。

简而言之，TCP为HTTP提供了底层的传输保障，而HTTP则在TCP的基础上实现了应用层的通信规则。两者共同作用，确保了数据在网络上的高效、可靠和安全传输。

## 8、TCP VS UDP

TCP（Transmission Control Protocol，传输控制协议）和UDP（User Datagram Protocol，用户数据报协议）是网络层之上的两个主要传输层协议，它们在互联网通信中扮演着核心角色。下面是对这两种协议的详细解释：

### TCP (Transmission Control Protocol)

TCP是一种面向连接的、可靠的、基于字节流的传输层协议。它通过三次握手建立连接，并通过四次挥手终止连接，确保数据的可靠传输。TCP的主要特点包括：

- **可靠性**：TCP使用确认应答、超时重传、校验和等机制来保证数据的可靠传输。如果数据包丢失或损坏，TCP会请求重新发送。

- **流量控制**：TCP使用滑动窗口机制来控制发送速率，避免发送方的数据速率超过接收方的处理能力，从而防止数据包的拥塞和丢失。

- **拥塞控制**：TCP能够检测网络的拥塞情况，并调整其发送速率以避免网络拥塞。

- **有序传输**：TCP保证数据按序到达，如果接收到乱序的数据包，TCP会重新排序。

- **面向连接**：在数据传输之前，必须先建立连接。这种连接是全双工的，即数据可以同时在两个方向上传输。

### UDP (User Datagram Protocol)

UDP是一种无连接的、不可靠的、基于数据报的传输层协议。它不提供数据传输的保证，但它的传输速度快，开销小。UDP的主要特点包括：

- **无连接**：UDP发送数据前无需建立连接，发送数据的同时也不维护连接状态，每个数据报都是独立传输的。

- **不可靠**：UDP不保证数据的可靠传输，不进行重传机制，也不提供确认应答，数据包可能丢失、重复或乱序。

- **低开销**：UDP的头部开销小，只有8字节，因此传输速度快，非常适合实时应用，如视频会议、语音通话等，这些应用对延迟敏感但能容忍一定比例的数据丢失。

- **广播和多播支持**：UDP支持广播和多播，允许单个数据报同时发送给多个接收者，这对于网络广播或组播应用非常有用。

### 应用场景对比

- **TCP**：适用于对数据完整性要求高、延迟容忍度低的应用场景，如网页浏览、文件传输（FTP）、邮件服务（SMTP/POP3）等。

- **UDP**：适用于对实时性要求高、数据包丢失容忍度高的应用场景，如在线游戏、实时音频/视频流、DNS查询等。

总体而言，TCP和UDP各有优劣，选择哪种协议取决于具体的应用需求和网络环境。

## 9、如何基于UDP做到TCP的哪种可靠传输

基于UDP实现类似TCP的可靠传输是一个挑战，因为UDP是一种无连接、不可靠的传输协议，它不提供数据包的确认、重传、排序或流量控制等机制。然而，通过在应用层实现这些功能，可以构建一个类似于TCP的可靠传输系统。以下是一些关键技术和策略，可以用来基于UDP实现可靠传输：

### 1. 序号和确认（ACK）
- **序号**：为每个发送的数据包分配一个序列号，这有助于接收方检测数据包的丢失或乱序，并请求重传缺失的数据包。
- **确认应答（ACK）**：接收方在收到数据包后，发送一个确认应答给发送方，确认已收到指定序号的数据包。如果发送方在一定时间内未收到确认，它将重传数据包。

### 2. 超时重传
- **重传机制**：如果发送方在设定的超时时间内没有收到接收方的确认应答，它将重传未确认的数据包。超时时间的设置需要考虑网络状况，避免过早或过晚重传。

### 3. 流量控制
- **滑动窗口**：类似于TCP的滑动窗口机制，可以限制发送方一次发送多少数据包，以避免接收方缓冲区溢出。发送方根据接收方的反馈（如ACK）动态调整窗口大小。

### 4. 拥塞控制
- **拥塞避免算法**：可以实现拥塞控制算法，如慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快重传（Fast Retransmit）和快恢复（Fast Recovery），以减少网络拥塞的风险。

### 5. 数据完整性
- **校验和**：为每个数据包添加校验和，接收方可以验证数据的完整性。如果校验和不匹配，数据包将被丢弃，并请求重新发送。

### 6. 乱序处理
- **排序机制**：接收方需要能够识别和处理乱序的数据包，将其重新排序以确保数据的正确性。

### 7. 高效的协议设计
- **协议头压缩**：为了减少开销，可以设计更紧凑的协议头，只包含必要的信息。
- **多路复用**：在单个连接上支持多个逻辑通道，允许同时传输不同类型的数据流。

### 8. 安全性
- **加密和认证**：可以实现加密和身份验证机制，以保护数据的机密性和完整性。

### 实际应用案例
- **QUIC协议**：Google开发的一种基于UDP的传输层协议，旨在提供类似TCP的可靠传输，同时优化了延迟和安全性。QUIC在Chrome浏览器和Google的HTTPS服务中得到广泛应用。
- **DTLS协议**：Datagram Transport Layer Security，为UDP数据报提供加密和认证，常用于实时通信应用，如WebRTC。

# WebSocket

## 1、什么是WebSocekt

WebSocket是一种在单个持久连接上进行全双工通信的协议，它被设计用于替代传统的HTTP轮询或长轮询技术，以实现客户端和服务器之间的实时交互。WebSocket提供了比HTTP更高效、更实时的数据交换方式，尤其适合需要持续数据流和即时响应的应用场景，如实时聊天、在线游戏、股票市场数据更新、实时协作编辑等。

### WebSocket的工作原理

1. **握手**：WebSocket的连接始于一个标准的HTTP请求，客户端发起一个特殊的GET请求，请求头中包含`Upgrade`和`Connection`字段，服务器如果支持WebSocket，则会响应一个`101 Switching Protocols`状态码，并且在响应头中包含相同的`Upgrade`和`Connection`字段，完成从HTTP到WebSocket的协议升级。

2. **全双工通信**：一旦握手成功，WebSocket连接就建立起来，客户端和服务器都可以随时发送数据给对方，而无需等待对方先发送或完成接收。这种全双工特性使得数据可以双向实时流动。

3. **帧结构**：WebSocket的数据传输是基于帧的，每个帧可以包含控制信息或实际的数据负载。帧的格式包括一个固定长度的头部和一个可变长度的负载数据部分，头部描述了数据的类型、长度、是否经过掩码处理等信息。

4. **掩码和解掩码**：为了安全起见，客户端发送的数据会被掩码处理，而服务器发送的数据则不进行掩码。接收端在读取数据之前需要进行相应的解掩码操作。

5. **关闭连接**：WebSocket连接可以通过发送特定的关闭帧来优雅地关闭，双方可以发送一个关闭帧，然后等待对方的确认关闭帧，最终断开连接。

### WebSocket的优势

- **低延迟**：相比于HTTP轮询，WebSocket提供了更低的延迟，因为不需要频繁的握手和连接建立过程。
- **全双工通信**：WebSocket支持客户端和服务器的双向实时通信，无需轮询或长轮询。
- **更少的带宽消耗**：WebSocket的帧结构紧凑，减少了不必要的HTTP头部开销，从而节省了带宽。
- **状态保持**：WebSocket连接保持打开状态，可以维持会话状态，无需每次请求都重新建立连接。

### WebSocket的使用

在Web开发中，JavaScript的`WebSocket` API提供了与WebSocket服务器交互的接口。浏览器可以通过创建`WebSocket`对象来建立连接，然后使用`onopen`、`onmessage`、`onclose`和`onerror`事件监听器来处理连接的不同阶段，同时使用`send`方法发送数据。

### WebSocket的限制

尽管WebSocket提供了很多优势，但它也有一些限制，比如：

- **浏览器兼容性**：虽然现代浏览器普遍支持WebSocket，但在一些老旧的浏览器版本中可能不支持。
- **防火墙和代理问题**：一些网络环境中的防火墙或代理服务器可能需要特殊配置才能允许WebSocket连接。
- **安全性和隐私**：尽管WebSocket本身使用TLS/SSL加密，但在传输敏感数据时仍需谨慎处理。

总之，WebSocket是一种强大而灵活的协议，它改变了Web应用程序的实时通信方式，使得实时数据传输变得更加容易和高效。