# 0. Go与其他语言



## 什么是面向对象：

面向对象 OOP：

* 面向对象编程是一种基于对象概念的编程范式，它可以包含数据和代码：数据以字段的形式存在（通常称为属性），代码是程序的形式存在（通常称为方法）；
* 对象自己的程序可以访问并经常修改自己的数据字段。
* 对象经常被定义为类的一个实例。
* 对象利用属性和方法的私有/受保护/公共可见性，对象的内部状态受到保护，不受外界影响（被封装）。

面向对象的三个基本特性；

## 1. Go语言和Java有什么区别

## 2. Go是面向对象的语言吗

## 3. Go实现面向对象编程

### 封装

### 继承

### 多态

## 4. Go 语言和python的区别



# 一、基础部分

## 0.为什么选择golang

## ==1.make 和new 的区别==

## 2.IO多路复用

## 3. for range 问题

for range 问题在1.22版本后正式优化了该问题

## 4. defer，多个defer的执行顺序；defer在什么情况下会修改return 返回值

作用：延迟函数；释放资源；收尾工作；释放锁、关闭文件、关闭连接、捕获panic；

多个defer调用顺序：LIFO 后入先出

defer 会修改 有名返回值或函数返回指针；

## 5.uint类型溢出问题

超过最大存储值如uint8最大是255

var a uint8 =255

var b uint8 =1

a+b = 0总之类型溢出会出现难以意料的事

## 6.rune类型

相当int32

golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8

==**byte 等同于int8，常用来处理ascii字符**==

==**rune 等同于int32,常用来处理unicode或utf-8字符**==

## 7. 解析tag是如何实现的？

## 8. 调用函数传入结构体时，应该传值还是指针

Golang 都是传值

Go 的函数参数传递都是值传递。

值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数

因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。

## 9.goroutine 什么情况下会阻塞

## 10.讲讲Select底层数据结构和一些特性（项目中是如何使用 select的）

go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测是否有读写事件是否 ready。

**select 的特性**

1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。

2）select 仅支持管道，而且是单协程操作。

3）每个 case 语句仅能处理一个管道，要么读要么写。

4）多个 case 语句的执行顺序是随机的。

5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。

## 11.讲讲 defer 底层数据结构和一些特性

每个 defer 语句都对应一个_defer 实例， 多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果

**defer 的规则总结**：

延迟函数的参数是 defer 语句出现的时候就已经确定了的。

延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。

延迟函数可能操作主函数的返回值。

申请资源后立即使用 defer 关闭资源是个好习惯。

## 12.单引号、双引号、反引号的区别

## 13. 出现panic额场景

- 数组/切片越界
- 空指针调用。比如访问一个 nil 结构体指针的成员
- 过早关闭 HTTP 响应体
- 除以 0
- 向已经关闭的 channel 发送消息
- 重复关闭 channel
- 关闭未初始化的 channel
- 未初始化 map。注意访问 map 不存在的 key 不会 panic，而是返回 map 类型对应的零值，但是不能直接赋值
- 跨协程的 panic 处理
- sync 计数为负数。
- 类型断言不匹配。`var a interface{} = 1; fmt.Println(a.(string))` 会 panic，建议用 `s,ok := a.(string)`

## 14. go是否支持while循环，如何实现这种机制

## 15. go如何实现set

## 16. go如何实现java的继承机制

## 17. 怎么去复用一个接口的方法？

## 18. go里面的_

1. 忽略返回值

2. 用在变量 特别是接口断言

3. 用在import package

   引入包时，会先调用包中的初始化函数，这种使用方式仅让导入的包做初始化，而不使用包中其他功能

## 19. goroutine 创建的时候如果要传入一个参数进去需要注意的点

## 20. 写go单元测试的规范

## 21. 单步测试

https://www.jianshu.com/p/21ed30859d80

## 22. 导入一个go的工程，有些依赖找不到，改怎么办？

## 23. 值拷贝、引用拷贝；深拷贝、浅拷贝；

map，slice，chan 是引用拷贝；引用拷贝 是 浅拷贝

其余的，都是 值拷贝；值拷贝 是 深拷贝

#### 深浅拷贝的本质区别：

是否真正获取对象实体，而不是引用

**深拷贝：**

拷贝的是数据本身，创造一个新的对象，并在内存中开辟一个新的内存地址，与原对象是完全独立的，不共享内存，修改新对象时不会影响原对象的值。释放内存时，也没有任何关联。

**值拷贝：**

接收的是  整个array的值拷贝，所以方法对array中元素的重新赋值不起作用。

**浅拷贝：**

拷贝的是数据地址，只复制指向的对象的指针，新旧对象的内存地址是一样的，修改一个另一个也会变。释放内存时，同时释放。

**引用拷贝：**

函数的引用拷贝与原始的引用指向同一个数组，所以对数组中元素的修改，是有效的

## 24. 精通Golang项目依赖Go modules

## 25. 多返回值怎么实现的？

Go语言利用了函数调用栈来管理返回值。当一个函数声明了多个返回值时，Go运行时会在栈上为每个返回值分配空间。当函数执行完毕时，这些返回值会被放置在栈上的特定位置，然后被调用者捕获。

## 26. Go 语言中不同的类型如何比较是否相等

## 27、Go中init 函数的特征?

## 28、Go中 uintptr和 unsafe.Pointer 的区别？

# 二、slice

## **1. 数组和切片的区别**

## 2. 讲讲Go的slice底层数据结构和一些特性？

## 3.golang中数组和slice作为参数的区别？slice作为参数传递有什么问题

## 4.从数组中取一个相同大小的slice有成本吗&从切片中取一个相同大小的数组有成本吗？



# 三、map

## 1. map使用注意的点，是否并发安全？

## 2. map循环是有序的还是无序的？

## 3. map 中删除一个key，它的内存会释放吗

## 4. 怎么处理对map进行并发访问？有没有其他方案？区别是什么？

## 5. nil map和空 map有何不同

## 6. map的数据结构是什么

## 7. map是怎么实现扩容

## 8. 查找过程

## 9. 插入过程

## 10. slices 能作为map类型的key吗



# 四、接口

## 1. Go语言与鸭子类型的关系

## 2. 值接收者和指针接收者的区别

## 3. iface和eface的区别是什么

## 4. 接口的动态类型和动态值

## 5. 编译器自动检测类型是否实现接口

## 6. 接口的构造过程是怎样的

## 7. 类型转换和断言的区别

## 8. 接口转换的原理

## 9. 如何用interface实现多态

## 10. Go 接口与C++接口有何异同



# 五、context

## 1. context结构是什么样的

## 2. context使用场景和用途



# 六、channel

## 1. channel 是否线程安全；锁用在什么地方

## 2. channel 的底层实现原理（数据结构）

## 3. nil和关闭的channel、有数据的channel，再进行读、写、关闭 channel 会怎样？

## 4. 向channel发送数据和从channel读数据的流程是怎么样的

## 5. 讲讲Go的chan底层数据结构和主要使用场景

## 6. 有缓存和无缓存channel



# 七、GMP

## 1. 进程、线程、协程有什么区别

## 2. 什么是GMP

## 3. 调度器的设计策略

## 4. 抢占式调度是如何抢占的

## 5. 调度器的生命周期



# 八、锁相关

## 1. 除了mutex 以外还有哪些方式安全读写共享变量

## 2. Go如何实现原子操作

## 3. Mutex 是悲观锁还是乐观锁？悲观锁和乐观锁是什么

## 4. Mutex 有几种模式

## 5. goroutine 的自旋占用资源如何解决



# 九、并发安全

## 1. 讲讲Go中主协程如何等待其他协程退出

## 2. 怎么控制并发数

## 3. 多个goroutine 对同一个map写会panic？异常是否可以用defer 捕获

## 4. golang实现多并发请求；发送多个get请求



# 十、GC

## 1.GC是怎么实现的

## 2. GC算法是怎么实现的

## 3. GC中stw时机，各个阶段是如何解决的

## 4. GC的触发时机



# 十一、内存相关

## 1. 内存分配原理

## 2. 垃圾回收原理

## 3. 逃逸分析

## 4. Go语言的内存模型及堆的分配管理

## 5. 谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？

## 6. golang 的内存逃逸吗？什么情况下会发生内存逃逸？（必问）

## 7. 请简述 Go 是如何分配内存的？

## 8. [go内存分配器](https://zhuanlan.zhihu.com/p/410317967)

## 9. Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？

## 10. 介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？



# 十二、编译

## 1. 逃逸分析是怎么进行的？

## 2. GoRoot 和GoPath 有什么用

## 3. Go编译相关的命令详解

## 4. Go程序启动过程是怎样的



# 十三、框架

## 1. Gin

## 2. go-zero

## 3. 字节 CloudWeGo

## 4. HTTP Hertz

## 5. RPC Kitex



## 