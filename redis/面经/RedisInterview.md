# RedisInterview

## 1、Redis 的数据类型



Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及 zsetsorted set：有序集合)。我们实际项目中比较常用的是 string，hash 。

如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、Geo、Pub/Sub。如果你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。

## 2、Redis 数据类型的使用场景

![img](E:/Typora%20picture/%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

- String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。
- List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
- Hash 类型：缓存对象、购物车等。
- Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
- Zset 类型：排序场景，比如排行榜、电话和姓名排序等。

Redis 后续版本又支持四种数据类型，它们的应用场景如下：

- BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；
- HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；
- GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；
- Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。

### 基本用户数据存储

在传统的数据库设计中，用户表是非常难以设计的，变更的时候会伤筋动骨。使用Redis的`hash`结构，可以实现松散的数据模型设计。某些不固定，验证型的功能属性，可以以JSON接口直接存储在hash的value中。使用hash结构，可以采用HGET和HMGET等指令，只获取自己所需要的数据，在使用上也是非常便捷的。

### 实现计数器

### 排行榜

Redis中有一个叫做zset的数据结构，使用跳表实现的有序列表，可以很容易实现排行榜一类的问题。当存入zset中的数据，达到千万甚至是亿的级别，依然能够保持非常高的并发读写，且拥有非常棒的平均响应时间（5ms以内）。

使用`zadd` 可以添加新的记录，我们会使用排行相关的分数，作为记录的score值，然后使用`zrevrange`指令即可获取实时的排行榜数据，而`zrevrank`则可以非常容易的获取用户的实时排名。

### 好友关系

`set`结构，是一个没有重复数据的集合，你可以将某个用户的关注列表、粉丝列表、双向关注列表、黑名单、点赞列表等，使用独立的zset进行存储。

使用`ZADD`、`ZRANK`等，将用户的黑名单使用ZADD添加，ZRANK使用返回的sorce值判断是否存在黑名单中。使用`sinter`指令，可以获取A和B的共同好友。

除了好友关系，有着明确黑名单、白名单业务场景的数据，都可以使用set结构进行存储。这种业务场景还有很多，比如某个用户上传的通讯录，计算通讯录的好友关系等等。

在实际使用中，使用zset存储这类关系的更多一些。zset同set一样，都不允许有重复值，但zset多了一个score字段，我们可以存储一个时间戳，用来标明关系建立所发生的时间，有更明确的业务含义。

### 统计活跃用户数

类似统计每天的活跃用户、用户签到、用户在线状态，这种零散的需求，实在是太多了。如果为每一个用户存储一个bool变量，那占用的空间就太多了。这种情况下，我们可以使用`bitmap`结构，来节省大量的存储空间。

### 分布式锁

Redis的分布式锁，是一种轻量级的解决方案。虽然它的可靠性比不上Zookeeper之类的系统，但Redis分布式锁有着极高的吞吐量。

一个最简陋的加锁动作，可以使用redis带nx和px参数的set指令去完成。下面是一小段简单的分布式样例代码。

### 分布式限流

使用计数器去实现简单的限流，在Redis中是非常方便的，只需要使用incr配合expire指令即可。

### 消息队列

redis可以实现简单的队列。在生产者端，使用LPUSH加入到某个列表中；在消费端，不断的使用RPOP指令取出这些数据，或者使用阻塞的BRPOP指令获取数据，适合小规模的抢购需求。

Redis还有PUB/SUB模式，不过pubsub更适合做消息广播之类的业务。

在Redis5.0中，增加了stream类型的数据结构。它比较类似于Kafka，有主题和消费组的概念，可以实现多播以及持久化，已经能满足大多数业务需求了。

### LBS应用

通过`GEOADD`指令追加lat、lng经纬数据，可以实现坐标之间的距离计算、包含关系计算、附近的人等功能。

关于GEO功能，最强大的开源方案是基于PostgreSQL的PostGIS，但对于一般规模的GEO服务，redis已经足够用了。

### 时间轴 Timeline

list作为双向链表，不光可以作为队列使用。如果将它用作栈便可以成为一个公用的时间轴。当用户发完微博后，都通过 lpush将它存放在一个 key 为 LATEST_WEIBO的 list中，之后便可以通过 lrange取出当前最新的微博。

### 循环链表

list 还可以作为循环链表使用 RPOPLPUSH source destination

命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：

- 将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。
- 将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。

如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。

比如有个进程来完成派单任务，需要将用户发送过来的申请依次派发给工作人员，那么就可以把工作人员的身份标示维护在循环列表中，从列表尾部读取每次读取身份标示后相应的标示都会被放到列表头如此循环往复。

### 倒排索引

倒排索引是构造搜索功能的最常见方式，在 Redis 中也可以通过 set进行建立倒排索引，这里以简单的拼音 + 前缀搜索城市功能举例：

假设一个城市 北京，通过拼音词库将 北京转为 beijing，再通过前缀分词将这两个词分为若干个前缀索引，有：北、 北京、 b、 be… beijin和 beijing。将这些索引分别作为 set的 key（例如: index:北）并存储 北京的 id，倒排索引便建立好了。接下来只需要在搜索时通过关键词取出对应的 set并得到其中的 id 即可。

## 3、使用 Redis 有哪些好处？

- 速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O1)
- 支持丰富数据类型，支持 string，list，set，Zset，hash 等
- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
- 丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除

## Memcache 是什么

Memcached（有时拼写为Memcache，但官方项目名为Memcached）是一种高性能、分布式内存对象缓存系统，它主要用于加速动态Web应用程序，通过减轻数据库负担来减少页面加载时间。Memcached通过在内存中缓存数据和对象，提供了一个简单而有效的缓存机制，从而大大提高了数据检索速度。

### 特点

1. **内存存储**：Memcached将数据存储在内存中，这比硬盘存储快得多，因为内存访问速度远高于磁盘访问速度。

2. **分布式**：Memcached可以部署在多个服务器上，形成一个分布式的缓存系统，这有助于提高缓存的可用性和扩展性。

3. **键值存储**：数据以键值对的形式存储，通过键（通常是字符串）来检索数据，这种存储方式非常灵活，可以存储各种类型的数据。

4. **无数据持久化**：Memcached默认不提供数据持久化，这意味着重启服务器后缓存的数据会丢失。这简化了实现，但也意味着数据是暂时的。

5. **客户端驱动的智能**：Memcached服务器不维护缓存项的依赖关系或失效规则，这些通常由客户端应用管理。

6. **简单协议**：Memcached使用一个简单的文本协议进行通信，易于理解和实现。

7. **自动分区**：当数据分布在多个Memcached服务器上时，客户端库会自动处理数据的分区，通常使用一致性哈希算法。

### 使用场景

Memcached广泛应用于各种需要高速数据访问的场景，如：

- **Web应用缓存**：存储数据库查询结果、用户会话、页面片段等。
- **API缓存**：缓存API调用的结果，减少对外部服务的依赖。
- **内容分发网络（CDN）**：缓存静态内容或动态生成的内容。
- **游戏服务器**：存储玩家状态、排行榜等。

### 实现和兼容性

Memcached是一个开源项目，支持多种操作系统，包括Linux、macOS和Windows。它有多种客户端实现，几乎所有的主流编程语言都有对应的客户端库，包括PHP、Python、Ruby、Java、Go等。

### 与Redis的区别

虽然Memcached和Redis都提供了类似的服务，但它们之间存在一些关键区别。Redis提供了更复杂的数据结构和持久化选项，而Memcached则更专注于简单的键值存储和高速缓存。Redis可以作为消息队列和发布订阅系统，而Memcached主要作为缓存系统。此外，Redis支持数据的持久化，而Memcached不提供这一功能。

## ES与Redis的区别

Elasticsearch (ES) 和 Redis 是两种非常不同的技术，尽管它们都可以用于数据存储和检索，但它们的设计目标和应用场景有很大的不同。下面是一些主要的区别：

### 1. 数据模型和用途

- **Elasticsearch**：
  - ES 是一个基于 Lucene 的搜索和分析引擎，主要用于全文搜索、数据分析和实时分析。
  - 它使用 JSON 文档作为数据存储单元，并支持复杂的查询语法，包括布尔查询、短语查询和地理空间查询等。
  - ES 提供了高级的聚合功能，允许用户执行复杂的统计分析和数据挖掘任务。

- **Redis**：
  - Redis 是一个内存中的数据结构存储，它可以作为一个数据库、缓存和消息中间件。
  - 它支持多种抽象的数据结构，如字符串、列表、集合、哈希表、排序集以及更复杂的数据结构如Bitmaps和HyperLogLogs。
  - Redis 被广泛用于缓存、会话存储、实时数据流处理、消息队列和发布/订阅模式。

### 2. 存储和持久化

- **Elasticsearch**：
  - ES 默认将数据存储在磁盘上，同时也使用内存缓存来加快读取速度。
  - 它支持数据的实时索引和搜索，但相比于 Redis，它的读写速度可能较慢，因为涉及到磁盘I/O。

- **Redis**：
  - Redis 主要是一个内存数据库，因此读写速度非常快。
  - 它提供了几种持久化机制，如 RDB 快照和 AOF 日志，以防止数据丢失。

### 3. 扩展性和集群

- **Elasticsearch**：
  - ES 支持水平扩展，可以通过增加更多的节点来提高性能和存储容量。
  - 它使用了一种称为“sharding”和“replication”的机制来分配数据和提供冗余。

- **Redis**：
  - Redis 也支持水平扩展，但直到最近版本才有了原生的集群支持（从 Redis 3.0 开始）。
  - Redis 集群使用了一致性哈希环来分割数据，但是与 ES 相比，其配置和管理可能更为复杂。

### 4. 性能

- **Elasticsearch**：
  - ES 在处理复杂的查询和大规模数据分析时表现出色，但在高并发的简单读写操作上可能不如 Redis。

- **Redis**：
  - Redis 在高并发的简单读写操作上表现优异，特别适合需要低延迟和高吞吐量的应用场景。

选择使用 Elasticsearch 还是 Redis 主要取决于具体的应用需求。如果你需要一个强大的搜索和分析引擎，那么 Elasticsearch 可能是更好的选择；如果你需要一个快速的内存数据库和缓存解决方案，那么 Redis 将是更合适的选择。

## 4、Redis 是单进程单线程的？

**Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的**

Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

### 4.1、Redis 单线程模式是怎样的

![img](E:/Typora%20picture/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.png)

图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I/O 和命令处理都是单线程。 Redis 初始化的时候，会做下面这几件事情：

- 首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket
- 然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；
- 然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。

初始化完后，主线程就进入到一个**事件循环函数**，主要会做以下事情：

- 首先，先调用**处理发送队列函数**，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。
- 接着，调用 epoll_wait 函数等待事件的到来：
  - 如果是**连接事件**到来，则会调用**连接事件处理函数**，该函数会做这些事情：调用 accpet 获取已连接的 socket -> 调用 epoll_ctl 将已连接的 socket 加入到 epoll -> 注册「读事件」处理函数；
  - 如果是**读事件**到来，则会调用**读事件处理函数**，该函数会做这些事情：调用 read 获取客户端发送的数据 -> 解析命令 -> 处理命令 -> 将客户端对象添加到发送队列 -> 将执行结果写到发送缓存区等待发送；
  - 如果是**写事件**到来，则会调用**写事件处理函数**，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。

## 5、一个字符串类型的值能存储最大容量是多少？

答：512M

## 6、Redis 集群最大节点个数是多少？

16384 个。

## 7、Redis 的内存用完了会发生什么？

当 Redis 的内存使用达到其配置的最大限制 (`maxmemory`) 时，它会根据配置的内存淘汰策略 (`maxmemory-policy`) 来决定如何处理后续的写操作。以下是可能发生的情况：

1. **noeviction 写入报错**:
   这是 Redis 的默认行为。当内存满了并且新的写操作尝试分配更多内存时，Redis 将直接返回一个错误给客户端，拒绝执行该操作。这通常意味着应用程序需要处理这些错误，并可能需要清理一些数据或增加 Redis 的内存限制。

2. **allkeys-lru 删除最少使用的键**:
   Redis 会根据最近最少使用 (Least Recently Used, LRU) 算法来淘汰数据。当内存不足时，它会自动移除最久未访问的键，以便为新数据腾出空间。

3. **volatile-lru 删除有过期时间的键**:
   类似于 `allkeys-lru`，但是只考虑设置了过期时间的键。这意味着没有过期时间的键将不会被淘汰。

4. **volatile-random 随机删除过期时间最近的键**:
   当内存不足时，随机挑选设置了过期时间的键进行淘汰。

5. **volatile-ttl 淘汰过期时间最近的键**:
   淘汰那些过期时间最近的键。

6. **allkeys-random 随机删除**: 
   当内存不足时，随机挑选键进行淘汰，不论键是否设置了过期时间。

## Redis 采用单线程为什么还这么快

- Redis 的大部分操作**都在内存中完成**，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；
- Redis 采用单线程模型可以**避免了多线程之间的竞争**，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。
- Redis 采用了 **I/O 多路复用机制**处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

## 8、Redis 的持久化机制是什么？各自的优缺点？

有两种持久化机制：RDB 快照 和 AOF 日志；

Redis 提供了两种主要的持久化机制：RDB（Redis Database Backup）快照和AOF（Append Only File）日志。每种机制都有其独特的优点和缺点，适用于不同的场景和需求。

### RDB（Redis DataBase Backup）

#### 优点：
1. **快速恢复**：由于RDB是一个数据快照，当Redis重启时，它可以迅速加载整个数据集，恢复速度快。
2. **更小的存储空间**：RDB文件通常比AOF文件小，因为它是数据的压缩版本，不含冗余的写命令。
3. **易于备份**：RDB文件是完整的数据集，在任意时间点都可以轻松备份，甚至可以传输到其他服务器上作为数据复制的基础。

#### 缺点：
1. **数据安全性较低**：由于RDB是在特定的时间点创建的快照，如果Redis在两次快照之间崩溃，可能会丢失从上次快照创建到故障发生这段时间内的数据。
2. **创建快照时的性能影响**：在创建RDB快照的过程中，如果使用了`SAVE`命令，Redis会阻塞所有客户端请求，直到快照完成。虽然`BGSAVE`命令可以在子进程中异步创建快照，但主进程在快照创建期间仍需要处理写操作，可能导致额外的内存使用。

### AOF（Append Only File）

![img](E:/Typora%20picture/6f0ab40396b7fc2c15e6f4487d3a0ad7.png)

#### 优点：
1. **更高的数据安全性**：AOF记录了所有写操作的命令，即使Redis在写操作后立即崩溃，也可以通过重放AOF文件来恢复数据，理论上可以提供接近实时的数据持久化。
2. **更好的容错性**：AOF文件可以被编辑，例如，可以通过AOF重写（`BGREWRITEAOF`命令）来压缩AOF文件，移除冗余的写操作，减小文件大小。

#### 缺点：
1. **更大的存储空间**：AOF文件通常比RDB文件大，因为它包含了所有的写操作命令。
2. **恢复速度较慢**：相比于RDB，AOF在Redis重启时需要更长的时间来重放所有的写命令，恢复数据集。

### 混合持久化

Redis还支持一种结合RDB和AOF的优点的混合持久化方式。在这种模式下，AOF重写过程中，首先会将当前数据集以RDB格式写入AOF文件，然后再追加新的写操作命令。这样既减少了AOF文件的大小，又保持了AOF的实时数据持久化特性。

### 选择持久化策略

在实际应用中，选择哪种持久化策略取决于你的业务需求。如果你需要极高的数据安全性，几乎不能容忍数据丢失，AOF可能是更好的选择。如果你更关心性能和存储效率，RDB可能更适合。在很多情况下，同时启用RDB和AOF，利用两者的优势，是最佳实践。例如，可以使用AOF来确保数据的安全性，同时使用RDB来定期创建数据快照，便于灾难恢复和数据备份。



## 9、Redis 的回收策略（淘汰策略）

Redis 的回收策略主要涉及两个关键方面：过期键的处理和内存溢出控制。下面是这两种策略的详细解释：

### 过期键处理

Redis 使用两种策略来处理设置了过期时间的键：

1. **惰性过期（Lazy Expiration）**:
   当一个设置了过期时间的键被访问时，Redis 会检查该键是否已经过期。如果是，键将被立即删除。这种方法可以节省系统资源，因为Redis不会主动扫描内存中的所有键来检查它们是否过期，而是只在键被访问时检查。

2. **定期过期（Regular Expiration）**:
   除了惰性过期之外，Redis 还会周期性地执行一个后台任务，随机检查一部分设置了过期时间的键，以检查它们是否过期。如果过期，键会被删除。这种策略是为了避免大量键同时过期，导致一次性消耗大量CPU资源。

### 内存溢出控制

当 Redis 达到其配置的最大内存限制 (`maxmemory`) 时，它将根据 `maxmemory-policy` 配置的策略来处理内存溢出。以下是几种可用的内存淘汰策略：

1. **noeviction**:
   当 Redis 内存达到上限时，新的写操作将被拒绝，并向客户端返回错误。这是默认策略，适用于不允许数据丢失的场景。

2. **allkeys-lru**:
   当内存不足时，Redis 将根据 LRU（最近最少使用）算法来淘汰键，允许新数据写入。

3. **volatile-lru**:
   类似于 `allkeys-lru`，但只淘汰设置了过期时间的键。

4. **volatile-random**:
   随机淘汰设置了过期时间的键。

5. **volatile-ttl**:
   根据键的过期时间淘汰键，优先淘汰过期时间最近的键。

6. **allkeys-random**:
   随机淘汰任何键，不论是否设置了过期时间。

每种策略都有其适用场景，选择哪一种取决于你的数据特性和业务需求。例如，如果你的应用程序可以容忍数据丢失，并且希望在内存紧张时继续接受写操作，那么选择基于 LRU 或随机淘汰的策略可能更合适。相反，如果你不能承受数据丢失的风险，`noeviction` 策略则是最佳选择。

另外，Redis 也提供了虚拟内存机制，允许将部分不常用的数据存储在磁盘上，以释放内存空间，但这会影响数据的访问速度。

## 10、Redis 过期键的删除策略？

- 1）定时删除:在设置键的过期时间的同时，创建一个定时器 timer).让定时器在键的过期时间来临时，立即执行对键的删除操作。
- 2）惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
- 3）定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

## 11、为什么 Redis 需要把所有数据放到内存中？

Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。在内存越来越便宜的今天， redis 将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

## 12、Redis 的同步机制了解么？

Redis 的同步机制主要包括主从同步（Master-Slave Replication）和读写分离（Read-Write Splitting），以及集群模式下的数据一致性保证。下面详细介绍这些机制：

### 主从同步（Master-Slave Replication）

主从同步是 Redis 中用于实现数据冗余和提高读取性能的一种机制。它允许从服务器（slave）对主服务器（master）进行数据复制。主从同步的过程可以分为以下几个步骤：

1. **全量同步（Full Resynchronization）**：
   - 当从服务器首次连接到主服务器时，或当从服务器丢失了大量数据时，会触发全量同步。
   - 主服务器创建一个 RDB 快照文件，并将其发送给从服务器。
   - 从服务器接收到 RDB 文件后，会加载数据并替换其当前的数据集。
   - 在 RDB 文件创建和传输期间，主服务器会使用缓冲区保存所有写操作，以确保从服务器能够获取最新的数据。
   - 当 RDB 文件传输完成后，主服务器会将缓冲区中的写操作发送给从服务器，以完成数据同步。

2. **增量同步（Partial Resynchronization）**：
   - 在全量同步之后，如果主服务器和从服务器之间的网络中断，或从服务器重启，它们可以使用复制偏移量（replication offset）来确定最后一次成功同步的位置。
   - 主服务器会发送自上次同步以来的所有写操作给从服务器，而不是重新传输整个数据集。
   - 这样可以减少带宽消耗和同步时间。

### 读写分离（Read-Write Splitting）

读写分离是通过主从同步自然实现的。在 Redis 架构中，主服务器负责写操作，而从服务器负责读操作。这样可以显著提高读取性能，因为读操作可以分布在多个从服务器上，而写操作只发生在主服务器上。

### 集群模式（Cluster Mode）

在 Redis 集群模式下，数据被分片（sharding）并分布在多个节点上，每个节点都可能承担着主服务器或从服务器的角色。集群模式下的数据一致性保证通过以下方式实现：

1. **分区（Partitioning）**：数据根据哈希槽（hash slots）分配到不同的节点上。
2. **故障转移（Failover）**：如果主节点失败，集群可以自动选举一个从节点升级为主节点，以维持服务的可用性。
3. **数据复制（Replication）**：每个主节点都有自己的从节点，用于数据冗余和读取扩展。
4. **投票机制（Voting）**：在故障转移过程中，从节点会通过投票机制选举新的主节点。

在面试中讨论 Redis 的同步机制时，理解主从同步的工作原理、读写分离的实现以及集群模式下的数据一致性保证是非常重要的。同时，了解这些机制的优缺点以及它们如何影响性能和可用性也是必要的。

## 13、Redis中什么是主管下线，什么是客观下线

在Redis中，"主管下线"（Master Down）和"客观下线"（Objectively Down）是与高可用性和故障转移相关的概念，特别是在Redis Sentinel（哨兵）机制中。Sentinel是Redis的一个组成部分，用于监控实例的健康状况、通知故障和自动故障转移。

### 主管下线（Master Down）
主管下线（Master Down）是指Sentinel集群中的一个Sentinel节点认为主节点（Master）已经不可用。但是，这仅是单个Sentinel节点的主观判断，并不一定代表其他Sentinel节点也同意这一观点。因此，主管下线是一个初步的判断，它可能基于以下条件之一：

- 主节点没有在规定的时间内回复PING命令。
- 主节点的故障状态持续了一段时间。

### 客观下线（Objectively Down）
客观下线（Objectively Down）是指Sentinel集群中的大多数节点都同意主节点已经不可用的状态。这是通过Quorum机制达成的共识，即超过一半的Sentinel节点必须同意主节点是Down的，才能将其标记为客观下线。客观下线是触发自动故障转移过程的前提条件。

一旦主节点被标记为客观下线，Sentinel集群将尝试进行故障转移，通常包括以下步骤：
1. 选举一个Sentinel节点来负责故障转移过程。
2. 将一个从节点（Slave）升级为主节点。
3. 更新其他从节点和客户端连接信息，指向新的主节点。

主管下线和客观下线的概念体现了Redis Sentinel的健壮性和容错能力，通过分布式共识机制确保在主节点出现故障时能够自动恢复服务，从而提高Redis集群的高可用性。

## 14、什么是主动缓存、被动缓存

### 主动缓存 (Proactive Caching)

主动缓存指的是在数据发生变化时，主动地将数据更新到缓存中。这种策略通常在数据源发生改变后立即触发，确保缓存中的数据是最新的。主动缓存适用于数据更新频率较高，且需要保持缓存数据与数据源高度一致性的场景。

例如，当数据库中的数据发生变化时，可以使用触发器、监听器或其他机制检测到这一变化，并立即将新数据推送到Redis缓存中。这样，下一次应用程序请求数据时，可以直接从Redis中获取最新的数据，而无需再次查询数据库。

### 被动缓存 (Passive Caching)

被动缓存则是在数据请求时检查缓存中是否存在所需数据，如果不存在，再去数据源获取数据，并将数据放入缓存中。这种方式不会主动去更新缓存，只有在数据被请求并且缓存中没有对应数据时才会从数据源拉取并填充缓存。

被动缓存适用于数据更新频率较低，或者数据的一致性要求不是非常严格的情况。例如，对于一些不经常改变的数据，如静态资源或查询结果，可以采用被动缓存策略，即在首次请求时填充缓存，之后的请求直接从缓存中获取数据，直到缓存过期。

## 15、什么是缓存雪崩、击穿、穿透

![图片](E:/Typora%20picture/61781cd6d82e4a0cc5f7521333049f0d.png)

### 缓存雪崩（Cache Avalanche）

缓存雪崩指的是**当大量缓存条目同时失效时，大量的请求直接落到后端数据库上，短时间内数据库的负载急剧增加，可能导致数据库服务不可用，进而影响整个系统的稳定性**。这种情况通常发生在缓存的生命周期设置不合理或者系统重启导致大量缓存被清空的情况下。

**解决策略**：

- **分散缓存过期时间**：不要让缓存集中在一个时间点过期，可以给缓存设置随机的过期时间。
- **限流与降级**：在缓存失效时，可以限制数据库请求的频率，并提供降级方案，返回默认值或旧数据。
- **预热缓存**：系统启动时预先加载常用数据到缓存中，避免用户请求触发缓存失效。

### 缓存击穿（Cache Punch Through）

缓存击穿是指**一个热点数据在缓存中失效的瞬间，大量的并发请求直接打到后端数据库上，造成数据库压力剧增**。这种情况通常发生在某个数据非常热门，且该数据恰好失效时。

**解决策略**：
- **互斥锁**：使用分布式锁机制来控制并发请求，确保同一时刻只有一个请求去数据库获取数据并更新缓存。
- **缓存预加载**：在数据即将过期前主动更新缓存，避免数据过期时并发请求直接打到数据库。
- **设置热点数据永不过期**：对于极其热点的数据，可以考虑将其设置为永不过期，或使用较长的过期时间。

### 缓存穿透（Cache Penetration）

缓存穿透是指**查询一个不存在的数据，由于缓存中没有命中，每次都去后端数据库查询，如果这种查询占比较大，就会对数据库造成很大压力。**在某些情况下，恶意用户可能会故意发送大量不存在的查询请求，以达到攻击的目的。

**解决策略**：
- **空值缓存**：将查询结果为空的情况也进行缓存，但可以设置较短的过期时间。
- **布隆过滤器（Bloom Filter）**：使用布隆过滤器预先判断数据是否存在，减少不必要的数据库查询。
- **接口层过滤**：在API层面过滤掉明显不合理的请求，减轻数据库的压力。

## 16、数据库和缓存如何保证一致性

####  先更新数据库，再删除缓存

![图片](E:/Typora%20picture/6e3db3ba2f829ddc14237f5c7c00e7ce.png)

**写策略的步骤：**

- 更新数据库中的数据；
- 删除缓存中的数据。

**读策略的步骤：**

- 如果读取的数据命中了缓存，则直接返回数据；
- 如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。

阿旺在想到「写策略」的时候，又陷入更深层次的思考，到底该选择哪种顺序呢？

- 先删除缓存，再更新数据库；
- 先更新数据库，再删除缓存。

阿旺这次经过上次教训，不再「想当然」的乱选方案，因为老板这次给的饼很大啊，必须把握住。

**「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的**。

聪明的阿旺还搞了个兜底的方案，就是给缓存加上了过期时间。

本以为就这样不会在出现数据一致性的问题，结果将功能上线后，老板还是收到用户的投诉「说自己明明更新了数据，但是数据要过一段时间才生效」，客户接受不了。

##### 重试机制

我们可以引入**消息队列**，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。

- 如果应用**删除缓存失败**，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是**重试机制**。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
- 如果**删除缓存成功**，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。

举个例子，来说明重试机制的过程。

![图片](E:/Typora%20picture/a4440f0d572612e0832b903e4a62bd2b.png)

##### [#](https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#订阅-mysql-binlog-再操作缓存)订阅 MySQL binlog，再操作缓存

「**先更新数据库，再删缓存**」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。

于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。

Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。

![图片](E:/Typora%20picture/2ee2280e9f59b6b4879ebdec6eb0cf52.png)

**如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。**

## 17、Redis 如何实现服务高可用

> 主从复制

主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。

主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。

![img](E:/Typora%20picture/2b7231b6aabb9a9a2e2390ab3a280b2d.png)

也就是说，所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。

注意，主从服务器之间的命令复制是**异步**进行的。

具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。

所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。

TIP

想更详细了解 Redis 主从复制的工作原理，可以详细看这篇：[主从复制是怎么实现的？(opens new window)](https://xiaolincoding.com/redis/cluster/master_slave_replication.html)

> 哨兵模式

在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。

为了解决这个问题，Redis 增加了哨兵模式（**Redis Sentinel**），因为哨兵模式做到了可以监控主从服务器，并且提供**主从节点故障转移的功能。**

![img](E:/Typora%20picture/26f88373d8454682b9e0c1d4fd1611b4.png)

TIP

想更详细了解 Redis 哨兵的工作原理，可以详细看这篇：[哨兵是怎么实现的？(opens new window)](https://xiaolincoding.com/redis/cluster/sentinel.html)

> 切片集群模式

当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 **Redis 切片集群**（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。

Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，**一个切片集群共有 16384 个哈希槽**，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：

- 根据键值对的 key，按照 [CRC16 算法 (opens new window)](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)计算一个 16 bit 的值。
- 再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。

接下来的问题就是，这些哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：

- **平均分配：** 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。
- **手动分配：** 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。

为了方便你的理解，我通过一张图来解释数据、哈希槽，以及节点三者的映射分布关系。

![img](E:/Typora%20picture/redis%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%98%A0%E5%B0%84%E5%88%86%E5%B8%83%E5%85%B3%E7%B3%BB.jpg)

上图中的切片集群一共有 2 个节点，假设有 4 个哈希槽（Slot 0～Slot 3）时，我们就可以通过命令手动分配哈希槽，比如节点 1 保存哈希槽 0 和 1，节点 2 保存哈希槽 2 和 3。

```c
redis-cli -h 192.168.1.10 –p 6379 cluster addslots 0,1
redis-cli -h 192.168.1.11 –p 6379 cluster addslots 2,3
```

然后在集群运行的过程中，key1 和 key2 计算完 CRC16 值后，对哈希槽总个数 4 进行取模，再根据各自的模数结果，就可以被映射到哈希槽 1（对应节点1） 和 哈希槽 2（对应节点2）。

需要注意的是，在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。

## 18、集群脑裂导致数据丢失怎么办？

> 什么是脑裂？

先来理解集群的脑裂现象，这就好比一个人有两个大脑，那么到底受谁控制呢？

那么在 Redis 中，集群脑裂产生数据丢失的现象是怎样的呢？

在 Redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。 如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。

这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在「从节点」中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— **脑裂出现了**。

然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，**因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题**。

总结一句话就是：由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。

> 解决方案

当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。

在 Redis 的配置文件中有两个参数我们可以设置：

- min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。
- min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。

我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。

这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。

即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，**原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了**。

**等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。**

再来举个例子。

假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。

同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。

这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了

## 19、Redis 可以保证 crash-safe 吗

Redis（Remote Dictionary Server）是一个开源的键值存储系统，它提供了多种机制来保证数据的持久性和crash-safety（崩溃安全性），即在系统崩溃后能够恢复到一个一致的状态。Redis通过以下几种方式来确保crash-safe：

1. **RDB（Redis Database Backup）快照**
   RDB是一种全量数据持久化方案，Redis会在指定的时间点将内存中的数据集快照写入一个数据文件（默认是dump.rdb）。当Redis重启时，它会从最近的RDB文件中恢复数据。这种方式可以保证在崩溃后从最近的快照恢复数据，但可能会丢失自上次快照以来的数据更新。

2. **AOF（Append Only File）**
   AOF是一种增量数据持久化方案，Redis会将每一个接收到的写命令追加到AOF文件中。当Redis重启时，它会重放AOF文件中的所有写命令来恢复数据。AOF提供了更高的数据安全性，因为即使在崩溃时，也可以从AOF文件中恢复最后一次写入的状态。此外，AOF文件可以被重写，以去除冗余命令，减小文件大小。

3. **混合使用RDB和AOF**
   Redis可以同时使用RDB和AOF来增强数据的安全性和恢复能力。RDB提供了快速的重启恢复，而AOF提供了更高水平的数据保护。

4. **主从复制（Master-Slave Replication）**
   Redis支持主从复制，即一个或多个从服务器（slave）可以实时地复制主服务器（master）的数据。如果主服务器发生故障，可以从服务器中选择一个作为新的主服务器，从而保证服务的连续性。

5. **集群和哨兵（Sentinel）**
   Redis集群可以提供数据的高可用性和故障转移。哨兵是一个监控系统，它可以监控主服务器和从服务器的健康状况，并在主服务器出现故障时自动进行故障转移，选择一个新的主服务器。

需要注意的是，虽然上述机制可以大大提高Redis的crash-safety，但没有任何系统能够100%保证在所有情况下都不会丢失数据。在极端的网络或硬件故障情况下，仍然可能会发生数据丢失。因此，合理配置Redis的持久化策略，以及定期备份RDB和AOF文件，是在生产环境中保障数据安全的重要措施。此外，根据业务需求和资源限制，选择合适的持久化策略是非常重要的。

## 20、Redis 抖动

Redis抖动通常指的是Redis在高负载或特定操作下，响应时间出现不稳定，导致延迟增加的现象。这种现象可能是由于多种因素引起的，以下是一些常见的原因和解决策略：

### 原因

1. **内存压力**：当Redis的内存使用接近上限时，它可能需要执行内存回收操作，如过期键的清理或数据淘汰策略（如`volatile-lru`、`allkeys-lru`），这些操作可能会占用CPU资源，导致延迟。

2. **大键操作**：对大键（包含大量数据的键）进行操作，如`GET`、`SET`、`DEL`，特别是在数据结构复杂或数据量大的情况下，可能会导致长时间的阻塞，影响其他操作的响应时间。

3. **CPU资源竞争**：在高并发或CPU资源紧张的情况下，Redis可能无法及时处理所有请求，导致响应时间延长。

4. **持久化操作**：Redis的持久化机制（RDB或AOF）在写入磁盘时可能会占用较多的CPU和I/O资源，尤其是在高速写入和大文件生成时，可能导致短暂的延迟。

5. **网络延迟**：在网络状况不佳或网络拥堵的情况下，Redis的请求和响应可能会经历较长的延迟。

### 解决策略

1. **优化内存使用**：
   - 使用更合适的                                                                                                                                   数据结构，减少内存占用。
   - 设置合理的最大内存限制和数据淘汰策略。
   - 定期清理过期或不再需要的键。

2. **避免大键操作**：
   - 将大键拆分为多个小键，减少单次操作的数据量。
   - 使用`SCAN`命令等非阻塞性命令来遍历大键。

3. **增加资源**：
   - 升级硬件，增加CPU和内存资源。
   - 考虑使用Redis集群或分片，分散负载。

4. **优化持久化策略**：
   - 减少RDB快照的频率，避免在高峰时段进行AOF重写。
   - 使用后台进程异步执行持久化操作，减少对主线程的影响。

5. **网络优化**：
   - 确保网络基础设施稳定，减少网络延迟。
   - 考虑使用Redis缓存客户端的连接池，减少连接建立和断开的开销。

6. **监控和调优**：
   - 使用Redis的`INFO`命令和监控工具，定期检查性能指标，识别瓶颈。
   - 根据监控数据调整配置参数，如调整`maxmemory-policy`、`appendonly`等。

Redis抖动可能会影响应用程序的性能和用户体验，因此，理解其背后的原因并采取相应的优化措施是至关重要的。在生产环境中，建议持续监控Redis的性能，并根据需要进行调优。