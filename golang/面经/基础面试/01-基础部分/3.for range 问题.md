## 3.for range 问题

1. 迭代顺序：数组、切片可以按照索引递增顺序迭代；map 不保证迭代顺序；
2. **复制元素vs 引用：**当你在 `for range` 循环中遍历切片或数组时，每次循环都会创建元素的一个副本。这意味着如果在循环内修改循环变量，不会影响原始切片或数组中的元素；对于映射和通道，`for range` 会返回键和值的副本。因此，如果在循环中修改这些值，不会影响映射中的原始值。
3. **并发问题**：如果在 `for range` 循环中启动新的 goroutine，循环变量在 goroutine 中可能是不可预测的。当循环结束时，循环变量的值可能会被重置，导致 goroutine 使用无效的值。为了避免这个问题，应该在每个 goroutine 中捕获循环变量的值。**当从一个通道读取时，`for range` 会阻塞直到通道关闭或者有可用的值。如果通道永远不会关闭且没有值发送，循环将永久阻塞。**
4. **映射迭代的终止条件**：映射的迭代器在映射被删除（`delete` 调用）时会停止，即使还有未迭代的元素。因此，在迭代映射时不要删除映射的元素。
5. **通道的关闭与检测：**当从通道读取时，如果通道被关闭且没有更多的值可以读取，`for range` 循环会终止。可以通过检查从通道读取的第二个返回值（布尔值）来确定是否是因为通道关闭而退出循环。

在 for a,b := range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不要直接把 a 或者 b 的地址传给协程。解决办法：在每次循环时，创建一个临时变量。

for range 问题在1.22版本后正式优化了该问题

